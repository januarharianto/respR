---
title: "`respR` - An R package for the analysis of respirometry data"
author: "Januar Harianto, Nicholas Carey, Maria Byrne"
output: 
  html_document:
    toc: false
    number_sections: true
    fig_caption: true
    theme: "default"
---

```{r, echo = F}
library(respR)
library(knitr)
library(readr)
Sys.setenv(TZ="Australia/Sydney")
# set pander table-layout options
library(pander)
panderOptions('table.alignment.default', function(df)
    ifelse(sapply(df, is.numeric), 'right', 'left'))
panderOptions('table.split.table', Inf)
panderOptions('big.mark', ",")
panderOptions('keep.trailing.zeros', TRUE)

opts_chunk$set(collapse = TRUE, comment = "#>", tidy = TRUE, highlight = TRUE)
```

# Abstract

1. Respirometry is a ubiquitous practice in experimental biology, but there is a lack of standard practices when analysing the resulting data, limiting transparency and reproducibility. As respirometry datasets become increasingly large and analytical approaches more complex, manipulating the data remains a challenge and often intractable with existing tools. 

2. Here we describe the `respR` R package, a collection of functions that implement a workflow-based approach to automate the analysis and visualisation of respirometry data. The package can be used for closed, intermittent flow, flow-through and open respirometry and uses well-defined sets of rules to reliably and rapidly generate reproducible results.

3. We demonstrate how `respR` uses novel computing methods such as rolling regressions and kernel density estimates to reliably detect maximum, minimum and most linear sections of the data, and critical oxygen tension, $P_{crit}$.

4. Although designed specifically with aquatic respirometry in mind, the object-oriented approach of the package and the unitless nature of its analytical functions mean that parts of the package can easily be used to estimate any other linear relationships in other research disciplines.


# Introduction

Metabolic rate is a fundamental trait associated with virtually all biological functions and is key in predicting patterns in ecology and conservation biology, from populations (Seibel and Drazen, 2007, Barneche et al., 2014) to ecosystems (Brown et al., 2004). It has been widely investigated in studies of the effects of external stressors on organisms, and is increasingly used to study resilience in climate change-related studies where warming is expected to drive increased metabolism in ectotherms (e.g. Pörtner, 2002, McElroy et al., 2012, Carey et al., 2016, Delorme & Sewell, 2016). By far the most common metric used to assess physiological performance in animals, metabolic rate has been determined from whole organisms to the level of cells and tissues (White & Kearney, 2013). Metabolic rate is typically quantified using respirometry, which measures oxygen uptake over time (Lighton, 2008).

There are four broad methodological approaches in respirometry: closed, intermittent flow, flow-through and open. In closed respirometry, $O_2$ decrease is measured within a hermetically sealed chamber of known volume, sometimes set within a closed loop to allow mixing of the environment within the chamber. Oxygen recordings may be continuous through use of an oxygen probe, periodic through withdrawing water or gas samples at set intervals, or a two-point measurement consisting of the initial and final concentrations. Metabolic rates are estimated from the $O_2$ timeseries by assuming a linear relationship between variables, and estimates of metabolic rate are straightforward in constant volume respirometry using the equation: $$VO_2 = \Delta O_2V$$ where $\Delta O_2V$ is the slope of the regression that describes the rate of change in $O_2$ concentration over time, or in the case of a two-point measurement, the difference in $O_2$ concentration divided by time elapsed, and $V$ is the volume of the container (Lighton, 2008). 
<!-- Note, we use here and in the package the term $RO_2$ to denote rate of $O_2$ depletion or uptake within an experiment. We use this term used to distinguish it from other common terms, for example $VO_2$ which is can be used to denote both volumetric O2 uptake and whole animal uptake, or $MO_2$ which typically denotes mass-specific uptake. -->


In intermittent flow respirometry, $O_2$ concentration is measured as described above, but periodically the chamber is flushed with new water or air, returning it to initial conditions, resealed, and the experiment repeated (Svendsen et al., 2016). This technique is essentially closed respirometry, but with the incorporation of repeated measures. Depending on the metabolic rate metric being investigated, final respiration rate can be calculated as the mean of the measures (e.g. Carey et al., 2016), or the lowest or highest rates recorded in any trial (e.g. Stoffels, 2015). 
<!--[nc-will try and find a better ref for that]

Stoffels, R. J. (2015). Physiological trade-offs along a fast-slow lifestyle continuum in fishes: What do they tell us about resistance and resilience to hypoxia? Plos One, 10(6), e0130303. https://doi.org/10.1371/journal.pone.0130303
-->

Flow-through respirometry involves a closed chamber, but with a regulated flow of air or water through it at a precisely determined rate. After equilibrium has been achieved, the oxygen concentration differential between the incurrent and excurrent channels, along with the flow rate, allows calculation of the oxygen extracted from the flow volume per unit time: $$VO_2 = (C_iO_2 - C_eO_2)FR$$ where $VO_2$ is the rate of $O_2$ consumption over time, $C_iO_2$ and $C_eO_2$ are the incurrent and excurrent $O_2$ concentrations, and $FR$ is the flow rate of water through the system  (Lighton, 2008).

A final method is open respirometry, in which an open tank or semi-enclosed area is used, but the input or mixing rate of oxygen from the surroundings is known or found to be negligible relative to oxygen consumption of the specimens (Leclercq et al., 1999). It is seldom used, but for some applications it is a sufficient and practical methodology (e.g. Gamble et al., 2014). The common equation used for open respirometry is: $$VO_2 = \Delta O_2V + \phi_d$$ where $\Delta O_2V$ is the slope of the regression that relates $O_2$ concentration to time, $V$ is the volume of the container and $\phi_d$ is the oxygen flux as determined by Fick's Law (Leclercq et al., 1999).

<!--[nc - so the following needs to be spot on. Physiologists get very worked up (if not confused themselves) about the differences between these, esp. SMR v Routine v Resting v Basal! Especially those who work on ecto vs endo therms]-->

Depending on the experiment, different metabolic rate parameters may be of interest to researchers. These include maximum metabolic rates (MMR, or $MO_{2,max}$), rates under high activity or exhaustive exercise, and minimal metabolic rates ($MO_{2,min}$), which may be termed standard (SMR), basal (BMR), or resting metabolic rates, and typically represents the minimum metabolic cost of maintaining biological functioning (White and Kearney, 2014). Routine metabolic rate (RMR), is similar to $MO_{2,min}$, but takes into account that in some organisms energy is expended on small, spontaneous movements to maintain posture or position (Rogers et al. 2016). Another metric of great interest is the critical oxygen tension, which represents the lowest level of oxygen at which aerobic metabolism is independent of the ambient partial pressure of oxygen ($P_{crit}$; Yeager & Ultsch, 1989, Hochachka and Somero, 2002). 

<!--White, C. R., & Kearney, M. R. (2014). Metabolic scaling in animals: methods, empirical results, and theoretical explanations. Comprehensive Physiology, 4(1), 231–256. https://doi.org/10.1002/cphy.c110049-->

Respirometry studies are increasingly outputting large, high-resolution datasets and conducted over longer periods (e.g. 20 h, Norin & Malte, 2012). In most cases, processing the data involves an *ad hoc* selection of data points with poorly reported criteria, and subsequent manual processing of the data subset(s) using a spreadsheet program (e.g. Microsoft Excel) or an integrated development environment (IDE, e.g. R or Matlab). These approaches can be tedious and time consuming especially when spreadsheet programs struggle with the vast datasets that are generated, while IDEs require a degree of expertise to use and have substantial learning curves. Dedicated software are also available to perform metabolic rate analyses, but many have costly licensing requirements (e.g. AutoResp by Loligo Systems), complicating or preventing their use on multiple machines, and are proprietary and closed-source, hindering scientific reproducibility and transparency.  

<!-- r.e. below para. LoLinR is not strictly for respirometry - just monotonic, something-changing-over-time data -->

A number of open-source R software packages have recently become available which are designed for, or are suitable to analyse respirometry data. The `respirometry` package (https://CRAN.R-project.org/package=respirometry) contains a comprehensive collection of tools to explore and evaluate experimental parameters in aquatic respirometry and is useful for the design and diagnosis of experimental setups. The `rMR` package (https://CRAN.R-project.org/package=rMR) performs interval-based metabolic rate calculations and has a method to automatically detect $P_{crit}$ using the "broken-stick" regression method (Yeager & Ultsch, 1989). `LoLinR` (Olito et al., 2017), while not specifically coded for respirometry, provides a statistically robust method of detecting a "best-fit" regression, and performs very well at identifying truly linear subsets of a data series. Importantly, all of these packages assume that data are monotonic with evenly-spaced sampling periods with respect to time, an ideal structure but one where respirometry data often fails to meet in reality. They also do not have the tools to analyse complicated datasets to automatically determine useful metric such as $MO_{2,max}$ and $MO_{2,min}$.

<!-- FIGURE 1 -->
Here we describe `respR`, an open-source R package designed to provide an efficient and reproducible workflow for the analysis of respirometry data. The package contains utilities to: (1) analyse closed, intermittent, flow-through and open respirometry data, (2) determine volume, mass, and surface area specific oxygen uptake rates, (3) automatically detect maximal and minimal rates, $P_{crit}$, and (4) detect the most linear sections of data using traditional rolling regression and kernel density estimation techniques. The package facilitates the output as supplementary material of all stages of respirometry analyses; raw data, subsetting criteria, background corrections, units of measure, and resulting metabolic rates. This streamlines the reporting of analytical methods and allows reviewers or other investigators to fully reproduce or scrutinise the results. Other functions useful in processing respirometry data are avaliable and are described in more detail in our online html vignette (https://januarharianto.github.io/respR/). The utility of the `respR` package is shown here using  data collected for closed, intermittent and flow-through respirometry. We show how `respR` might be used to determine $MO_{2,max}$, $MO_{2,min}$, and $P_{crit}$. 



# Package overview

The `respR` package streamlines the analysis of respirometry data by partitioning the data processing workflow into several independent actions: (1) initially, data are imported, checked for common errors, plotted for visual inspection and exported as an object; (2) the object is then analysed to estimate the desired rate parameter; (3) diagnostic plots are automatically generated and the data can be further explored using the generic S3 `print()`, `plot()`, and `summary()` commands to verify the results; (4) adjustments to the data, either from background respiration and/or oxygen flux in open respirometry, are applied; (5) volume or mass-specific rate conversions, specific to the respiratory chamber and specimen(s), are calculated where necessary (**Fig. 1**). By design, each step of the workflow requires minimal manual manipulation of the data, and the user can pass the output of each function to the next. This object-oriented approach makes `respR` easy to use, even for novice users of R, and allows us (or anyone interested in the open-source project) to easily extend the functionality of the package, either by adding additional intermediate actions or substituting current actions with other code without breaking the rest of the package. Note, we use $RO_2$ in the following text to represent the dimensionless rate of $O_2$ use with regard to the time unit, and to distinguish it from other commonly reported metrics (e.g. $MO_2$, $VO_2$).  

Installation of `respR` can be performed directly via the R console using `devtools`:

```{r eval=F}
# install.packages("devtools") 
devtools::install_github("januarharianto/respR")
library(respR)
```

To illustrate the main features of the package, 4 example datasets, `sardine.rd`, `urchin.rd`, `intermittent.rd` and `squid.rd` are distributed with `respR`. Detailed information about the example data, including their source and methods, can be obtained with the `?` command in the R console (e.g. `?sardine.rd`). 


# Data import and exploration

Data should be formatted correctly before use in `respR`. The function `inspect.data()` extracts a two-column data frame from a multi-column dataset and performs error checks on a data frame of any size, while plotting the data for quick data visualisation. All data should be numeric; respR at this time has limited support for date/time data (e.g. `POSIXct` and `POSIXt` classes). Parsing  different time formats is extremely complex and beyond the scope of this package, particularly because such packages already exist (e.g. `lubridate`). Time data, being a continuous variable, should be sequential, without duplicates. Ideally, sampling frequency will be monotonic, but in many cases this may not be the case, such as experiments with irregular sampling intervals, or because machine drift and/or data dropouts frequently occur during regular sampling. Therefore, `respR` uses time-based data extraction methods by default in most of its analytical functions (except `pcrit()`), and correctly handles irregular timeseries data.

<!-- ...Identifying irregularities in the sampling time is therefore important as it as variations in data intervals may cause systemic bias in the analysis, especially if data loss or machine drift during sampling is persistent through time and time-based comparisons are made between experiments. -->

Using `inspect.data()` is optional -- the main functions in our package will readily work with data frames that were not processed by the function. Running `inspect.data()` is an exploratory step that flags potential issues before analysis. Error check results are summarised in the R console and all tests are saved in the output object with the locations (i.e. row numbers) of the errors:

```{r}
inspect.data(squid, plot = F)
```

## Data analysis

### Calculating background $RO_2$

Background oxygen consumption rate ($RO_({2(bg)}$) is often measured to account for the contribution of microbial respiration, and applied as a correction to experimental rates (Rodgers et al., 2016). Background rates typically account for a small percentage of experimental rates, and multiple “blank” experiments are usually conducted and the rates averaged to obtain a more accurate estimate of the correction (e.g. Carey and Sigwart, 2014; Daoud et al., 2007). The function `calc.rate.bg()` uses simple linear regression to simultaneously process multiple background rate measurements. Data segments can be truncated before analysis by time period or row numbers. The results are stored as an object for later use.

### Extracting data and calculating $RO_2$

Typically, the analysis respirometry data requires the selection one or more linear sections of the raw data for more accurate calculations of $RO_2$ (e.g. Gordon et al., 1989, Dorey et al., 2014, Chu & Gal, 2017). The function `calc.rate()` can manually extract and process data subset from respiromety data. Data subsets can be selected by (1) time period, (2) row numbers, (3) $O_2$ decrease or (4) proportion, which should accommodate most, if not all, manual data selection requirements and allow for consistent reporting of methods and results. Rates are determined using linear regression, however a two-point analysis is also included alongside all regression results.

For more complex respirometry parameters, the function `auto.rate()` uses novel rolling regression and kernel density estimate algorithms to detect patterns in respirometry data. It can calculate maximum or minimum rates, extract rates at non-overlapping intervals, and has an exploratory method to detect the most linear sections of the data. When called, the function takes the data frame of length $m$, and performs regressions of sample size $n$ iteratively across the length of the data (i.e. rolling regressions), one sample at a time (**Fig. 2a**). Thus, a total of $(m−n)+1$ number of overlapping regressions are fitted, which are then ranked to obtain maximum and minimum values. If an interval-based regression is required, we select the `"interval"` method when calling the function, and it automatically selects non-overlapping sections of the data for regressions (**Fig. 2b**).


To estimate the most linear sections of the data, further computations are performed after rolling regressions. Logically, linear sections of the data should reflect a consistently stable (i.e. flat) rate. If the rate changes at some point during the sampling period, then the rolling estimate should detect the variability. This function takes advantage of this relationship and performs a Gaussian kernel density estimate (KDE) of all regressions (see Silverman, 1986). Peaks in the density thus reflect stable rates, and new segments of the data within the kernel bandwidth of the peak values are resampled and re-analysed to determine the most linear sections. Summary diagnostics and visual plots provide supporting information on the technique and the validity of the results (**Fig. 3**).

The function `calc.rate.ft()` is used to specifically analyse flow-through respirometry data, and is similar to `calc.rate()` in functionality. However it accepts additional inputs of incurrent and excurrent oxygen concentration, and flow rate.`calc.rate.ft()` can process data to determine the mean or modal $RO_2$ over a period.

### Estimating critical oxygen tension, $P_{crit}$

We provide two methods of estimating $P_{crit}$. The first is a "broken-stick" regression (BSR) approach, adopted from Yeager and Ultsch (1989) in which two segments of the data are iteratively fitted and the intersection with the smallest sum of the residual sum of squares between the two linear models is the estimated critical point. The second method is a wrapper for the segmented, or "broken-line" regression approach, presented by Muggeo (2003) and available as an R package (Muggeo 2008), which estimates the critical point by iteratively fitting two intersecting models on the data and selecting the point that minimises the "gap" between the two fitted lines.

As $P_{crit}$ is the break-point in the relationship between ambient dissolved oxygen ($DO_2$) and $RO_2$/$MO_2$, the user has two options to provide the required data. Loading an $O_2$ timeseries data into the function will prompt it to automatically perform a rolling mean and a rolling regression of $DO_2$ to extract those variables (**Fig. 4**). Alternatively, the user already has the required data, and the function may run the data directly using the argument `has.rate = TRUE`.

## Correcting, converting and scaling data

### Corrections for oxygen flux and background respiration

The function `adjust.rate()` can be used to correct $RO_2$ estimates for oxygen flux and/or background respirometry data. As the oxygen consumption units are not mass specific at the point of correction, the function adjusts RO_2 directly without bias using the equation: $$RO_{2(correction)} = RO_2 - (\phi_d + RO_{2(bg)})$$ where $\phi_d$ is the oxygen flux and $RO_{2(bg)}$ is background respiration.

### Rate conversions

For deliberate reasons, units of measurement are not used when determining $RO_2$ in `respR`. Instead, two functions, `convert.rate()` and `scale.rate()`, are used to transform $RO_2$ to specific units and perform volumetric or mass-specific conversions . This unique approach has the advantage of allowing "dimensionless" rate calculations for data that may not be fully supported by the entire respR workflow. For example, measurements of respiration can be scaled to surface area (e.g. diatoms, Iversen & Ploug, 2013, Naumann et al., 2014), volume (e.g. copepod eggs, Hammervold et al., 2015), or density (e.g. sea urchin larvae, Stumpp et al., 2011), which are currently unsupported. Users may also be interested in using respR's analytical functions to investigate other linear relationships or perform breakpoint analyses on non-respirometry-related data.

The function `convert.rate()` is used to convert units of oxygen concentration only (e.g. $mg/L$ or %) and has support for various unit combinations (Table 2). For ease of use, we have implemented a simple fuzzy string-matching algorithm to match relevant units even when they have been provided in different formats (e.g. "$mg/L$", "$mg/l$", "$mg L^{-1}$" and "$mg l^{-1}$" are identified as the same units). The function `scale.rate()` is conceptually similar to `convert.rate()`, but it focuses volumetric and mass-specific conversions (e.g. $mg h^{-1} kg^{-1}$).

# Concluding remarks and future improvements
The package `respR` implements a number of methods not available in any other R package or software. These include the use of rolling regression techniques to estimate $MO_{2,max}$, $MO_{2,min}$, and $P_{crit}$, the use of kernel density estimation techniques to rank linear segments of the data, support for unevenly-spaced time data, and the ability to extract and analyse data precicely by time, row, or $O_2$ concentration. In particular, there are clear advantages to using `respR` when estimating parameters for $MO_{2,max}$ or $MO_{2,min}$. Unlike manual methods where data ranges may be arbitrary selected, `respR` adheres to well-defined rules to obtain rates of interest, and its methods are results are transparent and fully reproducible. The `respR` package allows for more effective and less time-consuming handling and processing of the very large data sets that are increasingly common in respirometry research.

# Tables & Figures

<!-- TAB 1 ----------------------------------------------------->
**Table 1.** Main functions available in `respR`.

```{r, echo=F, message=F}
# use this later to show table
library(readr)
listfunctions <- readxl::read_excel('tables/list-of-functions.xlsx')
conversions <- readxl::read_excel("tables/conversion-units.xlsx")
```

```{r, echo=F, results='asis'}
pander(listfunctions)
```


<!-- TAB 2 ----------------------------------------------------->
**Table 2.** Units available for conversions in `calc.rate()` and `scale.rate()`. 

```{r, echo = F, results='asis'}
pander(conversions)

```

<!-- FIG 1 ----------------------------------------------------->

```{r, echo = F, out.width = "800px"}
knitr::include_graphics("figs/Figure 1.png")
```

**Fig. 1.** Diagram showing steps in a typical workflow in the analysis of respirometry data using `respR`. Data are first checked for errors before the main functions are used to extract and analyse segments of the data. Summarised results and diagnostic plots provide immediate visual feedback on the outcome of the analyses. Once the rate estimates are obtained, they can be converted into volume and/or mass-specific rates.

<!-- FIG 2 ----------------------------------------------------->

```{r, echo = F, out.width = "650px"}
knitr::include_graphics("figs/Figure 2.png")
```

**Fig. 2** Illustration showing the sampling method used by `auto.rate()` during **(A)** interval regression analysis, where sample windows do not overlap and **(B)** rolling regression analysis, where sample windows overlap and move forward by one sample unit at a time.
<!-- FIG 3 ----------------------------------------------------->

```{r, echo = F, , out.width = "800px"}
knitr::include_graphics("figs/Figure 3.png")
```

**Fig. 3** Typical graphical outputs of the function `auto.rate()`. **(A)** Depending on the `method` input, the function is able to show: (clockwise form top left) the maximum rate detected, the minimum rate detected, calculation of rate by fixed-width intervals, and the most linear region as determined by kernel density estimates. **(B)** In addition, the outputs will also print diagnostic plots of: (clockwise from top left) the rolling regression of rate as a function of time with dotted lines indicating the region used to estimate the parameter, a kernel density plot that shows only when the `linear` method is called, a residual plot of the regression, and a normal Q-Q plot of the residuals of the regression. Analysis is performed using the example dataset `sardine`, which is included in the package. Code to reproduce the plots is available in the Supplementary Material.

<!-- FIG 44 ----------------------------------------------------->

```{r, echo = F, , out.width = "800px"}
knitr::include_graphics("figs/Figure 4.png")
```

**Fig. 4** Output plots of the function `pcrit()`, used in the calculation of critical oxygen tension, $P_{crit}$. **(A)** To determine $P_{crit}$ in a regular $O_2$ timeseries, the function performs a rolling regression againt the rolling mean of the data. This produces **(B)** data that represents the rate of $O_2$ consumption as a function of $O_2$ concentration. Regression lines are then fitted iteratively, based on the broken-stick methods of Yeager and Ultsch (1989) and the segmented approach of Muggeo (2003), until convergence is achieved. The output then highlights the critical points as indicated by the coloured lines.

# Supplementary material
```{r, eval = F}

# Measuring intermittent data
# Load data:
data("intermittent") 
int <- inspect.data(intermittent) # check for errors
# Calculate rate in 3 locations:
int.rate <- calc.rate(int, c(200,2300,4100), c(1800,3200,4600), by = 'time')
plot(int.rate, rep = 1)

# Estimating max, min, interval, most linear (best-fit) rates
data("sardine")
sar <- inspect.data(sardine) # check for errors
sar.max <- auto.rate(sar, width = 1500, method = "max") # maximum rate
sar.min <- auto.rate(sar, width = 1500, method = "min") # minimum rate

sar.int <- auto.rate(sar, width = 1500, method = "interval") # interval sampling
print(sar.int)
summary(sar.int)
plot(sar.int, pos = 3) # view the plots for the third interval of the data

sar.lin <- auto.rate(sar, width = 1500, method = "linear") # most linear rate
sar.lin # same as print(sdd.max)
print(sar.lin, pos = 2) # view rank 2 results
plot(sar.lin, pos = 2) # plot rank 2 results
summary(sar.lin) # summary call

# NOTE: using using sample number as roll width is possible and exponentially faster.
# We can switch to `by = "row"` if time is evenly-spaced.
sar.max.row <- auto.rate(sar, width = 1500, by = "row", method = "max") # maximum rate


# Pcrit analysis
data(squid)
sqd <- inspect.data(squid, 2, 3)
# Perfomr pcrit using defaut
sqd.pcrit <- pcrit(sqd) # this may take a while as over 30k regressions are performed
sqd.pcrit # same as print(sqd.pcrit)

```
