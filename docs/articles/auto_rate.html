<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>auto_rate 1: Automatic detection of metabolic rates • respR</title>
<link rel="shortcut icon" type="image/x-icon" href="../favicon.ico">
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script><!-- sticky kit --><script src="https://cdnjs.cloudflare.com/ajax/libs/sticky-kit/1.1.3/sticky-kit.min.js" integrity="sha256-c4Rlo1ZozqTPE2RLuvbusY3+SU1pQaJC0TjuhygMipw=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="auto_rate 1: Automatic detection of metabolic rates">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">respR</a>
        <span class="label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">1.0.4</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/respR.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/auto_rate.html">auto_rate 1: Automatic detection of metabolic rates</a>
    </li>
    <li>
      <a href="../articles/auto_rate_comp.html">auto_rate 3: Comparative performance of auto_rate and LoLinR</a>
    </li>
    <li>
      <a href="../articles/closed.html">Closed-chamber respirometry</a>
    </li>
    <li>
      <a href="../articles/flowthrough.html">Flowthrough respirometry</a>
    </li>
    <li>
      <a href="../articles/importing.html">Importing your data</a>
    </li>
    <li>
      <a href="../articles/intermittent.html">Intermittent-flow respirometry 1: Simple example</a>
    </li>
    <li>
      <a href="../articles/intermittent2.html">Intermittent-flow respirometry 2: Complex example</a>
    </li>
    <li>
      <a href="../articles/packages_comp.html">respR vs. other R packages</a>
    </li>
    <li>
      <a href="../articles/pcrit.html">Pcrit</a>
    </li>
    <li>
      <a href="../articles/performance.html">auto_rate 2: Performance in detecting linear regions</a>
    </li>
    <li>
      <a href="../articles/reproducibility.html">Open science and reproducibility using respR</a>
    </li>
    <li>
      <a href="../articles/tidyverse.html">respR and the Tidyverse</a>
    </li>
    <li>
      <a href="../articles/twopoint.html">Two-point analyses</a>
    </li>
    <li>
      <a href="../articles/when_to_use.html">When to use `respR`</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/januarharianto/respr">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><script src="auto_rate_files/htmlwidgets-1.2/htmlwidgets.js"></script><script src="auto_rate_files/viz-0.3/viz.js"></script><link href="auto_rate_files/DiagrammeR-styles-0.2/styles.css" rel="stylesheet">
<script src="auto_rate_files/grViz-binding-1.0.0/grViz.js"></script><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>auto_rate 1: Automatic detection of metabolic rates</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/januarharianto/respr/blob/master/vignettes/auto_rate.Rmd"><code>vignettes/auto_rate.Rmd</code></a></small>
      <div class="hidden name"><code>auto_rate.Rmd</code></div>

    </div>

    
    
<div id="introduction" class="section level2">
<h2 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h2>
<p>In respirometry, we often want to report oxygen uptake rates that represent experimentally important stages or physiological states. These include:</p>
<ul>
<li>the most consistent (i.e. most linear) rates observed, often most representative of <em>routine</em> metabolic rates.</li>
<li>minimum rates observed, often most representative of <em>standard</em>, <em>resting</em> or <em>maintenance</em> metabolic rates.</li>
<li>maximum rates observed, representative of <em>active</em> or <em>maximal</em> metabolic rates.</li>
</ul>
<p>The problem is that over long datasets identifying these regions is difficult, and if selected visually are subject to bias and lack of observer objectivity. Other methods, such as fitting multiple, fixed-width linear regressions over the entire dataset to identify regions of minimum or maximum slopes is computationally intensive, and slopes found via this method highly sensitive to the width chosen, especially if the specimen’s metabolic rate may change rapidly.</p>
<p>Here we present <code><a href="../reference/auto_rate.html">auto_rate()</a></code>, a function in the <code>respR</code> package that uses rolling regression techniques to automatically detect <strong>most linear</strong>, <strong>maximum</strong> and <strong>minimum</strong> rates within a dataset. This function can be used to select linear, max and min rates in an statistically robust, objective way. In this vignette we detail how <code><a href="../reference/auto_rate.html">auto_rate()</a></code> works, and how it can be used to extract rates from respirometry data. In the <strong>LINK</strong> vignette, we show how we have tested this method against simulated data, and the <strong>LINK</strong> vignette its performance against another linear detection method. We show it perfoms extremely well on large datasets in determining linear rates. Importantly, <code><a href="../reference/auto_rate.html">auto_rate()</a></code> has been optimised to be extremely fast. Other methods on large datasets can take minutes or hours to run. We show how <code><a href="../reference/auto_rate.html">auto_rate()</a></code> can reduce this wait by orders of magnitude, literally fitting tens of thousands of regressions and detecting linear regions in seconds.</p>
</div>
<div id="overview" class="section level2">
<h2 class="hasAnchor">
<a href="#overview" class="anchor"></a>Overview</h2>
<p>This illustrates the main processes involved in <code><a href="../reference/auto_rate.html">auto_rate()</a></code>:</p>
<div id="htmlwidget-b776df37d326b48f376e" style="width:681.6px;height:576px;" class="grViz html-widget"></div>
<script type="application/json" data-for="htmlwidget-b776df37d326b48f376e">{"x":{"diagram":"\ndigraph a_nice_graph {\n\n# node definitions with substituted label text\n\nnode [fontname = Helvetica, shape = circle]\nrd [label = \"Raw Data\"]\n\nnode [fontname = Helvetica, shape = rectangle]\nrr [label = \"1. Rolling linear regression\"]\nkd [label = \"2. Kernel density\nestimates\"]\nre [label = \"3. Bandwidth resampling\"]\nlr [label = \"4. Linear regression\"]\nar [label = \"5. Rank\"]\nfi [label = \"6. Filter\"]\n\nnode [fontname = Menlo, shape = none]\nau [label = \"auto_rate()\"]\nli [label = \"linear,\"]\nmm [label = \"max, min\"]\nin [label = \"interval\"]\n\n# edge definitions with the node IDs\n\nrd -> au -> rr -> ar -> mm\nrr -> kd -> re -> lr -> ar -> li\nrr -> fi -> in\n\n}","config":{"engine":"dot","options":null}},"evals":[],"jsHooks":[]}</script><p><code><a href="../reference/auto_rate.html">auto_rate()</a></code> works by performing an optimised rolling regression on the dataset. A kernel density estimate is performed on the rolling regression output and the kernel bandwidth used to re-sample linear regions of the data for re-analysis.</p>
</div>
<div id="rolling-linear-regression" class="section level2">
<h2 class="hasAnchor">
<a href="#rolling-linear-regression" class="anchor"></a>Rolling linear regression</h2>
<p>The function <code><a href="../reference/auto_rate.html">auto_rate()</a></code> uses a novel method of combining rolling regression and kernel density estimate algorithms to detect patterns in time series data. The rolling regression runs all possible ordinary least-squares (OLS) linear regressions <span class="math inline">\((y = \beta_0 + \beta_1 X + \epsilon)\)</span> of a fixed sample width across the dataset, and is expressed as: <span class="math display">\[y_t(n) = X_t(n) \beta (n) + \epsilon_t(n), \ t = n,\ ...,\ T\]</span> where <span class="math inline">\(T\)</span> is the total length of the dataset, <span class="math inline">\(n\)</span> is the window of width <span class="math inline">\(n &lt; T\)</span>, <span class="math inline">\(y_t(n)\)</span> is the vector of observations (e.g. oxygen concentration), <span class="math inline">\(X_t(n)\)</span> is the matrix of explanatory variables, <span class="math inline">\(\beta (n)\)</span> is a vector of regression parameters and <span class="math inline">\(\epsilon_t(n)\)</span> is a vector of error terms. Thus, a total of <span class="math inline">\((T - n) + 1\)</span> number of overlapping regressions are fit. These are then ranked to obtain maximum and minimum values. An interval-based rolling regression can be selected (<code>method = "interval"</code>), and it automatically selects non-overlapping sections of the data for regressions, but all other methods fit overlapping regressions.</p>
</div>
<div id="kernel-density-estimation" class="section level2">
<h2 class="hasAnchor">
<a href="#kernel-density-estimation" class="anchor"></a>Kernel density estimation</h2>
<!-- Additional methods are automatically applied when we use `auto_rate()` to detect linear sections of the data.  -->
<!-- First, a Gaussian kernel density estimate (KDE) is used to process the regression coefficient $\beta$, based on the key assumption that linear sections of the data are reflected by relatively stable parameters across the rolling estimates. -->
<!-- This assumption is used often in financial statistics to evaluate stability and make predictions on time-series data. -->
<!-- Here, KDE automatically aggregates stable (i.e. linear) sections as they naturally form one or more local maximums ("modes") in the probability density estimate, and if the distribution is multimodal, the modes are ranked by size. -->
<p>Additional analytical techniques are automatically applied when we use <code><a href="../reference/auto_rate.html">auto_rate()</a></code> to detect linear sections of the data. First, we take advantage of the key assumption that linear sections of a data series are reflected by stable parameters across the rolling estimates, a property that is often applied in financial statistics to evaluate model stability and make forward predictions on time-series data (see Zivot and Wang 2006). We use kernel density estimation (KDE) techniques, often applied in various inference procedures such as machine learning, pattern recognition and computer vision, to automatically aggregate stable (i.e. linear) segments as they naturally form one or more local maximums (“modes”) in the probability density estimate.</p>
<p>KDE requires no assumption that the data is from a parametric family, and learns the shape of the density automatically without supervision. KDE can be expressed as: <span class="math display">\[\hat{f}(x) = \frac{1}{nh^d}\sum_{i = 1}^{n} K \left(\frac{x - X_i}{h} \right)\]</span> where <span class="math inline">\(f\)</span> is the density function from an unknown distribution <span class="math inline">\(P\)</span> for <span class="math inline">\(X_1,...,X_n\)</span>, <span class="math inline">\(K\)</span> is the kernel function and <span class="math inline">\(h\)</span> is the optimal smoothing bandwidth. The smoothing bandwidth is computed using the solve-the-equation <em>plug-in</em> method (Sheather et al. 1996, Sheather and Jones 1991) which works well with multimodal or non-normal densities (Raykar and Duraiswami 2006).</p>
<!-- The smoothing bandwidth $h$ is computed using an adjusted kernel bandwidth selector based on Silvermans "rule of thumb" (Silverman, 1986): $$h = \left(\frac{4\hat{\sigma}^5}{3n} \right)^{\frac{1}{5}} \approx 1.06\hat{\sigma}n^{-\frac{1}{5}}$$ where $\hat{\sigma}$ is the standard deviation of the samples and $n$ is the total number of samples.  -->
<p>We then use <span class="math inline">\(h\)</span> to select all values in the rolling regression output that match the range of values around each mode (<span class="math inline">\(\theta_n\)</span>) of the KDE (i.e. <span class="math inline">\(\theta_n \pm h\)</span>). These rolling estimates are grouped and ranked by size, and the upper and lower bounds of the data windows they represent are used to re-select the linear segment of the original data series. The rolling estimates are then discarded while the detected data segments are analysed using linear regression.</p>
</div>
<div id="adjusting-the-width-of-rolling-regressions" class="section level2">
<h2 class="hasAnchor">
<a href="#adjusting-the-width-of-rolling-regressions" class="anchor"></a>Adjusting the width of rolling regressions</h2>
<p>By default, <code><a href="../reference/auto_rate.html">auto_rate()</a></code>’s rolling regression uses a rolling window value in rows of <code>0.2</code> multiplied by the total length of the number of samples. This can be changed by changing the <code>width</code> argument, to a proportion relative to the total size of the data (<code>width = 0.1, by = "row"</code>) or a fixed value in the time metric (<code>width = 3000, by = "time"</code>).</p>
<p>It is important to note that the width determines the exact width of the data segments produced for <code>max</code>, <code>min</code> and <code>interval</code> rates. This allows the user to consistently report results across experiments, such as reporting the maximum or minimum rates sustained over a specified time period.</p>
<p>Importantly, the <code>width</code> does <em>not</em> restrict the maximum width of the segments produced for linear detection. <strong>We advise users to use caution when changing the <code>width</code> argument if using <code>method = "linear"</code>.</strong> Choosing an inappropriate width value tends to over-fit the data for rolling regression.</p>
<p>Below, we show the differences in the shape of the rolling regressions when using a <code>width</code> of <code>0.6</code> to analyse <code>sardine.rd</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Perform linear detection; default width (when not specified) is 0.2:</span>
normx &lt;-<span class="st"> </span><span class="kw"><a href="../reference/auto_rate.html">auto_rate</a></span>(sardine.rd, <span class="dt">plot =</span> <span class="ot">FALSE</span>)
<span class="co">#&gt; </span>
<span class="co">#&gt; 46 kernel density peaks detected and ranked.</span>

<span class="co"># Perform linear detection using manual width of 0.6:</span>
overx &lt;-<span class="st"> </span><span class="kw"><a href="../reference/auto_rate.html">auto_rate</a></span>(sardine.rd, <span class="dt">plot =</span> <span class="ot">FALSE</span>, <span class="dt">width =</span> .<span class="dv">6</span>)
<span class="co">#&gt; </span>
<span class="co">#&gt; 19 kernel density peaks detected and ranked.</span>

<span class="co"># Plot ONLY the rolling regression plots for comparison:</span>
<span class="kw">par</span>(<span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>), <span class="dt">mai =</span> <span class="kw">c</span>(<span class="fl">0.4</span>, <span class="fl">0.4</span>, <span class="fl">0.3</span>, <span class="fl">0.3</span>), <span class="dt">ps =</span> <span class="dv">10</span>,
    <span class="dt">cex =</span> <span class="dv">1</span>, <span class="dt">cex.main =</span> <span class="dv">1</span>)
<span class="kw">plot</span>(normx, <span class="dt">choose =</span> <span class="dv">3</span>)
<span class="co">#&gt; </span>
<span class="co">#&gt; # plot.auto_rate # ----------------------</span>
<span class="co">#&gt; Done.</span>
<span class="kw">plot</span>(overx, <span class="dt">choose =</span> <span class="dv">3</span>)
<span class="co">#&gt; </span>
<span class="co">#&gt; # plot.auto_rate # ----------------------</span></code></pre></div>
<p><img src="auto_rate_files/figure-html/rollreg_demo-1.png" width="681.6"></p>
<pre><code>#&gt; Done.</code></pre>
<p>Under perfectly linear conditions, we would expect the rolling regression output to produce a straight, horizontal line with a slope of 0, i.e. a very stable plot. Since KDE automatically aggregates stable values, a poor selection of the <code>width</code> value may result in a badly-characterised rolling estimate output. In the example presented above, while the default width showed a pattern of relative stability after 3,000 seconds, that information was lost when a <code>width</code> of <code>0.6</code> was used. Thus, the KDE technique would not have had the appropriate information necessary to correctly detect any linear patterns in the same data.</p>
</div>
<div id="most-linear-rates" class="section level2">
<h2 class="hasAnchor">
<a href="#most-linear-rates" class="anchor"></a>Most linear rates</h2>
<p>By default, <code><a href="../reference/auto_rate.html">auto_rate()</a></code> identifies the <em>most linear</em> region of the data (i.e. <code>method = "linear"</code>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span>urchins.rd[,<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">15</span>)]
<span class="kw"><a href="../reference/auto_rate.html">auto_rate</a></span>(x)
<span class="co">#&gt; </span>
<span class="co">#&gt; 10 kernel density peaks detected and ranked.</span></code></pre></div>
<p><img src="auto_rate_files/figure-html/unnamed-chunk-2-1.png" width="681.6"></p>
<pre><code>#&gt; 
#&gt; # auto_rate # ---------------------------
#&gt; Data is subset by row using width of 48 
#&gt; Rates were computed using 'linear' method
#&gt; 10 linear regions detected in the kernel density estimate
#&gt; 
#&gt; Rank 1 of 10 :
#&gt; Rate: -0.02200647 
#&gt; R.sq: 0.99 
#&gt; Rows: 5 to 178 
#&gt; Time: 0.7 to 29.5</code></pre>
<p>This represents the most consistently linear region, that is most consistent rate observed during the experiment. It does this in a statistically rigorous manner, which removes observer subjectivity from choosing which rate is most appropriate to report in their results. It calculates these <em>most linear</em> rates across all possible data window widths, so this also removes the need to the user to specify this. It is a statistically robust way of indentifying and reporting consistent rates in respirometry data.</p>
</div>
<div id="minimum-and-maximum-rates" class="section level2">
<h2 class="hasAnchor">
<a href="#minimum-and-maximum-rates" class="anchor"></a>Minimum and maximum rates</h2>
<p><code><a href="../reference/auto_rate.html">auto_rate()</a></code> can also be used to detect the maximum and minimum rates over a fixed sample width, either as proportion of the dataset (e.g. the default <code>width = 0.2, by = "row"</code>), or a fixed period of time (e.g. <code>width = 600, by = "time"</code>). This allows for consistent reporting of respirometry results, such as the maximum or minimum rates sustained over a specified time period. Note, that while still fast in comparison to some other methods, this second method of specifying a <code>time</code> window can be considerably slower. This is because it is telling <code><a href="../reference/auto_rate.html">auto_rate()</a></code> that the time data may have gaps or not be evenly spaced, and so the function calculates each (in this example) 600 point width using the raw time <em>values</em>, rather than assuming a specific row width represents the same time window. If your data is without gaps and evenly spaced with regards to time, this option is not really necessary, and <code>by = row</code> and the correct proportional <code>width</code> for the time you want should be used, as it is much faster.</p>
<div id="maximum-rates" class="section level5">
<h5 class="hasAnchor">
<a href="#maximum-rates" class="anchor"></a>Maximum rates:</h5>
<p>Here we want to know the maximum rates sustained over 10 minutes, or 600s, in the <code>sardine.rd</code> data. Since in these data, O2 data is recorded every second and <code><a href="../reference/inspect.html">inspect()</a></code> tells us the time data is gapless and evenly spaced, we can simply specify width in the correct number of rows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/inspect.html">inspect</a></span>(sardine.rd)
<span class="co">#&gt; No issues detected while inspecting data frame.</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; # inspect # -----------------------------</span>
<span class="co">#&gt;               Time Oxygen</span>
<span class="co">#&gt; NA/NAN        pass   pass</span>
<span class="co">#&gt; sequential    pass      -</span>
<span class="co">#&gt; duplicated    pass      -</span>
<span class="co">#&gt; evenly-spaced pass      -</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/auto_rate.html">auto_rate</a></span>(sardine.rd, <span class="dt">width =</span> <span class="dv">600</span>, <span class="dt">method =</span> <span class="st">"max"</span>)</code></pre></div>
<p><img src="auto_rate_files/figure-html/unnamed-chunk-4-1.png" width="681.6"></p>
<pre><code>#&gt; 
#&gt; # auto_rate # ---------------------------
#&gt; Data is subset by row using width of 600 
#&gt; Rates were computed using 'max' method
#&gt; 
#&gt; Rank 1 of 6914 :
#&gt; Rate: -0.001193478 
#&gt; R.sq: 0.85893 
#&gt; Rows: 795 to 1394 
#&gt; Time: 794 to 1393</code></pre>
</div>
<div id="minimum-rates" class="section level5">
<h5 class="hasAnchor">
<a href="#minimum-rates" class="anchor"></a>Minimum rates:</h5>
<p>We can similarly find the minimum rate over 10 minutes, and here we will save the output to object <code>x</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw"><a href="../reference/auto_rate.html">auto_rate</a></span>(sardine.rd, <span class="dt">width =</span> <span class="dv">600</span>, <span class="dt">method =</span> <span class="st">"min"</span>)</code></pre></div>
<p><img src="auto_rate_files/figure-html/unnamed-chunk-5-1.png" width="681.6"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(x)
<span class="co">#&gt; </span>
<span class="co">#&gt; # auto_rate # ---------------------------</span>
<span class="co">#&gt; Data is subset by row using width of 600 </span>
<span class="co">#&gt; Rates were computed using 'min' method</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Rank 1 of 6914 :</span>
<span class="co">#&gt; Rate: -0.0005399376 </span>
<span class="co">#&gt; R.sq: 0.58528 </span>
<span class="co">#&gt; Rows: 2260 to 2859 </span>
<span class="co">#&gt; Time: 2259 to 2858</span></code></pre></div>
</div>
<div id="additional-ranked-results" class="section level5">
<h5 class="hasAnchor">
<a href="#additional-ranked-results" class="anchor"></a>Additional ranked results:</h5>
<p><code><a href="../reference/auto_rate.html">auto_rate()</a></code> objects contain all the results for the specified width (or in the case of <code>method = linear</code> all results for <em>all</em> widths). By default, the first ranked (i.e. most maximum or minimum) result is returned, but others and their locations can be examined using the <code>summary</code> command:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(x)
<span class="co">#&gt; Regressions : 6914 | Results : 6914 | Method : min | Roll width : 600 | Roll type : row </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; === Summary of Results ===</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;       intercept_b0       rate_b1       rsq  row endrow time endtime</span>
<span class="co">#&gt;    1:     94.69693 -0.0005399376 0.5852845 2260   2859 2259    2858</span>
<span class="co">#&gt;    2:     94.69981 -0.0005410793 0.5864181 2259   2858 2258    2857</span>
<span class="co">#&gt;    3:     94.70265 -0.0005422043 0.5875352 2258   2857 2257    2856</span>
<span class="co">#&gt;    4:     94.23211 -0.0005430376 0.6155883 5844   6443 5843    6442</span>
<span class="co">#&gt;    5:     94.70663 -0.0005437765 0.5875985 2261   2860 2260    2859</span>
<span class="co">#&gt;   ---                                                              </span>
<span class="co">#&gt; 6910:     95.90508 -0.0011928894 0.8588085  801   1400  800    1399</span>
<span class="co">#&gt; 6911:     95.90536 -0.0011930839 0.8588811  791   1390  790    1389</span>
<span class="co">#&gt; 6912:     95.90540 -0.0011932450 0.8588905  792   1391  791    1390</span>
<span class="co">#&gt; 6913:     95.90557 -0.0011934783 0.8589309  795   1394  794    1393</span>
<span class="co">#&gt; 6914:     95.90576 -0.0011934783 0.8589309  796   1395  795    1394</span>
<span class="co">#&gt;       rowlength timelength</span>
<span class="co">#&gt;    1:       600        599</span>
<span class="co">#&gt;    2:       600        599</span>
<span class="co">#&gt;    3:       600        599</span>
<span class="co">#&gt;    4:       600        599</span>
<span class="co">#&gt;    5:       600        599</span>
<span class="co">#&gt;   ---                     </span>
<span class="co">#&gt; 6910:       600        599</span>
<span class="co">#&gt; 6911:       600        599</span>
<span class="co">#&gt; 6912:       600        599</span>
<span class="co">#&gt; 6913:       600        599</span>
<span class="co">#&gt; 6914:       600        599</span></code></pre></div>
<p>Particular ranked results can be examined or extracted via the <code>plot</code> and <code>summary</code> commands, using the <code>pos</code> (for position) operator:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Second most minimum rate detected
<span class="kw">plot</span>(x, <span class="dt">pos =</span> <span class="dv">2</span>)
<span class="co">#&gt; </span>
<span class="co">#&gt; # plot.auto_rate # ----------------------</span></code></pre></div>
<p><img src="auto_rate_files/figure-html/unnamed-chunk-7-1.png" width="681.6"></p>
<pre><code>#&gt; Done.
summary(x, pos = 2)
#&gt; Regressions : 6914 | Results : 6914 | Method : min | Roll width : 600 | Roll type : row 
#&gt; 
#&gt; === Summary of Ranked  2 Result ===
#&gt; 
#&gt;    intercept_b0       rate_b1       rsq  row endrow time endtime rowlength
#&gt; 1:     94.69981 -0.0005410793 0.5864181 2259   2858 2258    2857       600
#&gt;    timelength
#&gt; 1:        599</code></pre>
<p>Note, the output objects of the <code>max</code> and <code>min</code> are essentially identical, the only difference being the results are ordered descending or ascending by rate, respectively. Therefore in this example, the <em>maximum</em> rate (i.e. <em>least</em> minimum) can be found by extracting the <em>last</em> result.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(x, <span class="kw">nrow</span>(x<span class="op">$</span>summary))
<span class="co">#&gt; </span>
<span class="co">#&gt; # auto_rate # ---------------------------</span>
<span class="co">#&gt; Data is subset by row using width of 600 </span>
<span class="co">#&gt; Rates were computed using 'min' method</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Rank 6914 of 6914 :</span>
<span class="co">#&gt; Rate: -0.001193478 </span>
<span class="co">#&gt; R.sq: 0.85893 </span>
<span class="co">#&gt; Rows: 796 to 1395 </span>
<span class="co">#&gt; Time: 795 to 1394</span></code></pre></div>
<!-- ### Interval rate -->
<!-- ```{r} -->
<!-- x <- auto_rate(sardine.rd, width = 1000, method = "interval") -->
<!-- print(x, 4)  # select the 4th interval result -->
<!-- ``` -->
<!-- ### Detecting and measuring linear regions -->
<!-- The function `auto_rate()` performs automatic detection of linear data by default: -->
<!-- ```{r} -->
<!-- x <- auto_rate(sardine.rd) -->
<!-- ``` -->
</div>
</div>
<div id="summary-of-when-to-use-different-auto_rate-options" class="section level2">
<h2 class="hasAnchor">
<a href="#summary-of-when-to-use-different-auto_rate-options" class="anchor"></a>Summary of when to use different <code>auto_rate</code> options</h2>
<p><code>method = linear</code><br>
In ‘steady state’ experiments. That is, when you are looking for the most <em>consistent</em> or <em>representative rates</em> for what the specimen is experiencing. This could represent routine metabolic rate, or in the case of an animal under constant excercise a consistent active metabolic rate. No <code>width</code> needs to be specified under this option.</p>
<p><code>method = max</code><br>
When your specimen is active at some point during the experiment, or has been exercised and placed in a respirometer, and you want to know its <em>maximum</em> rate over a specific time period or row width. The default is <code>width = 0.2, by = "row"</code> (0.2 of total row number) or it can be specified in the time unit, e.g. <code>width = 600, by = "time"</code>). This should be carefully selected, and consistent if you are comparing specimens.</p>
<p><code>method = min</code><br>
Similarly, when your specimen is inactive, quiescent, dormant, etc., and you want to know the lowest rates over a specified time period. This is often representative of resting, basal or standard metabolic rates. Again, this necessarily requires a time window (<code>width</code>) to be specified, which should be carefully selected, and consistent if you are comparing specimens.</p>
<p><code>method = interval</code> This is chiefly for comparison with historical data, or if you have a specific reason to specify non-overlapping regressions. JANUAR!</p>
<div id="when-not-to-use-auto_rate" class="section level4">
<h4 class="hasAnchor">
<a href="#when-not-to-use-auto_rate" class="anchor"></a>When <em>not</em> to use auto_rate</h4>
<ul>
<li>
<strong>Flowthrough respirometry data</strong><br>
See <code><a href="../reference/calc_rate.ft.html">?calc_rate.ft</a></code>. This respirometry method is currently unsupported in <code>auto_rate</code>, but it is in our plans to add this.</li>
<li>
<strong>Intermittent flow respirometry, without some subsetting or specification of measurement periods</strong><br>
While we have had generally good results using <code>auto_rate</code> on intermittent-flow data, there is a strong possibility flush periods could confuse the algorithms on occasion. See LINK vignette for how to get around this. And as always, inspect outputs plots to ensure data locations are relevant.</li>
</ul>
</div>
</div>
<div id="further-processing" class="section level2">
<h2 class="hasAnchor">
<a href="#further-processing" class="anchor"></a>Further processing</h2>
<p>Saved <code><a href="../reference/auto_rate.html">auto_rate()</a></code> objects can be passed to subsequent <code>respR</code> functions for further processing, such as <code><a href="../reference/adjust_rate.html">adjust_rate()</a></code> to correct for background respiration, or <code><a href="../reference/convert_rate.html">convert_rate()</a></code> to convert to final O2 uptake rates.</p>
</div>
<div id="examples" class="section level2">
<h2 class="hasAnchor">
<a href="#examples" class="anchor"></a>Examples</h2>
<p>Examples are available in the <a href="https://januarharianto.github.io/respR/reference/index.html">reference section</a>. You may also run <code><a href="../reference/auto_rate.html">?auto_rate</a></code> in the R console to access some examples in the help file.</p>
</div>
<div id="references" class="section level2">
<h2 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h2>
<p>Jones, M. C., Marron, J. S., &amp; Sheather, S. J. (1996). A Brief Survey of Bandwidth Selection for Density Estimation. Journal of the American Statistical Association, 91(433), 401–407. <a href="doi:10.1080/01621459.1996.10476701" class="uri">doi:10.1080/01621459.1996.10476701</a></p>
<p>Olito, C., White, C. R., Marshall, D. J., &amp; Barneche, D. R. (2017). Estimating monotonic rates from biological data using local linear regression. The Journal of Experimental Biology, jeb.148775-jeb.148775. <a href="doi:10.1242/jeb.148775" class="uri">doi:10.1242/jeb.148775</a></p>
<p>Raykar, V., &amp; Duraiswami, R. (2006). Fast optimal bandwidth selection for kernel density estimation. In Proceedings of the Sixth SIAM International Conference on Data Mining (Vol. 2006). <a href="doi:10.1137/1.9781611972764.53" class="uri">doi:10.1137/1.9781611972764.53</a></p>
<p>Sheather, S. J., &amp; Jones, M. C. (1991). A Reliable Data-Based Bandwidth Selection Method for Kernel Density Estimation. Journal of the Royal Statistical Society. Series B (Methodological), 53(3), 683–690.</p>
<p>Zivot, E., &amp; Wang, J. (2006). Modeling Financial Time Series with S-PLUS (2nd ed.). New York: Springer-Verlag.</p>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#introduction">Introduction</a></li>
      <li><a href="#overview">Overview</a></li>
      <li><a href="#rolling-linear-regression">Rolling linear regression</a></li>
      <li><a href="#kernel-density-estimation">Kernel density estimation</a></li>
      <li><a href="#adjusting-the-width-of-rolling-regressions">Adjusting the width of rolling regressions</a></li>
      <li><a href="#most-linear-rates">Most linear rates</a></li>
      <li><a href="#minimum-and-maximum-rates">Minimum and maximum rates</a></li>
      <li><a href="#summary-of-when-to-use-different-auto_rate-options">Summary of when to use different <code>auto_rate</code> options</a></li>
      <li><a href="#further-processing">Further processing</a></li>
      <li><a href="#examples">Examples</a></li>
      <li><a href="#references">References</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Januar Harianto, Nicholas Carey.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  

  </body>
</html>
