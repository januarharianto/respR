<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Assessing the performance of respR’s auto_rate function in detecting linear data • respR</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><meta property="og:title" content="Assessing the performance of respR’s auto_rate function in detecting linear data">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">respR</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/respR.html">Get Started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/auto_rate.html">Automatic detection of respirometry parameters</a>
    </li>
    <li>
      <a href="../articles/flowthrough.html">Flowthrough respirometry</a>
    </li>
    <li>
      <a href="../articles/intermittent.html">Analysis of intermittent-flow data</a>
    </li>
    <li>
      <a href="../articles/pcrit.html">Determining Pcrit</a>
    </li>
    <li>
      <a href="../articles/performance.html">Assessing the performance of respR's auto_rate function in detecting linear data</a>
    </li>
    <li>
      <a href="../articles/twopoint.html">Two-point analyses</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/januarharianto/respr">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>Assessing the performance of respR’s auto_rate function in detecting linear data</h1>
            
          </div>

    
    
<div class="contents">
<p>The function <code><a href="../reference/auto_rate.html">auto_rate()</a></code> uses rolling regression and kernel density estimation techniques to automatically detect the most linear sections of respirometry data. The dimensionless nature of the function, however, also allows it to be applied to any serial data. To our knowledge, the methods we use here are novel, and not reported in past publications involving linear data detection and analysis of biological data. Olito et al. (2016) describes a different, though very robust, method to detect and rank linear segments in data using their R package, <code>LoLinR</code>. A brief comparison of <code><a href="../reference/auto_rate.html">auto_rate()</a></code> and <code>LoLinR</code>’s methods are discussed at the end of this document.</p>
<div id="testing-the-linear-detection-method-of-auto_rate" class="section level2">
<h2 class="hasAnchor">
<a href="#testing-the-linear-detection-method-of-auto_rate" class="anchor"></a>Testing the linear detection method of auto_rate</h2>
<p>To ensure that <code><a href="../reference/auto_rate.html">auto_rate()</a></code> performs as intended, we created two internal functions designed to test the accuracy of our KDE techniques to detect linear data. The first function, <code><a href="../reference/sim_data.html">sim_data()</a></code>, generates a random dataset which contains both linear and non-linear segments. The second function, <code><a href="../reference/test_lin.html">test_lin()</a></code>, specifically performs <code><a href="../reference/auto_rate.html">auto_rate()</a></code> repeatedly on randomly generated data and aggregates the performance metrics obtained to assess and visualise the accuracy of the KDE technique. Both functions are published with the <code>respR</code> package, thus anyone can use them – as we show below – or run them with their own input paramters.</p>
<p>The performance tests that we provide are by no means comprehensive, but provide a starting point in generating the data necessary for users to make informed decisions on using and further testing <code><a href="../reference/auto_rate.html">auto_rate()</a></code> for their own purposes.</p>
</div>
<div id="generating-simulated-data-for-tests" class="section level2">
<h2 class="hasAnchor">
<a href="#generating-simulated-data-for-tests" class="anchor"></a>Generating simulated data for tests</h2>
<p><code><a href="../reference/sim_data.html">sim_data()</a></code> is used to randomly generate three kinds of data based on the <code>method</code> argument, which we briefly describe below. It accepts inputs to customise the length of the data (no. of samples), the type of data (described below), the degree of noise ad specified by the standard deviation of the data (default 0.05), and a preview toggle to plot and visualise the simulated dataset.</p>
<div id="default-data" class="section level3">
<h3 class="hasAnchor">
<a href="#default-data" class="anchor"></a>“Default” data</h3>
<p><code><a href="../reference/sim_data.html">sim_data(method = "default")</a></code></p>
<p>A non-linear segment is first generated using a sine or cosine function with a random length of <code>floor(abs(rnorm(1, .25*len, .05*len)))</code>, where <code>len</code> is the total number of observations in the data defined in the function argument, and a random amplitude of <code>rnorm(1, .8, .05)</code>. This data segment is appended to a linear segment with a randomly-generated slope computed using <code>rnorm(1, 0, 0.02)</code>. The shape of the dataset is designed to mimic common respirometry data whereby the initial sections of the data are often non-linear. Here we show 25 randomly-generated plots created by the method:</p>
<p><img src="performance_files/figure-html/defaultdata-1.png" width="681.6"></p>
</div>
<div id="corrupted-data" class="section level3">
<h3 class="hasAnchor">
<a href="#corrupted-data" class="anchor"></a>“Corrupted” data</h3>
<p><code><a href="../reference/sim_data.html">sim_data(method = "corrupted")</a></code></p>
<p>Same as <code>"default"</code>, but “corrupted” data is inserted randomly at any point in the linear segment. The data corruption is depicted by a sudden dip in the reading, which recovers. This event mimics equipment interference that does not necessarily invalidate the dataset if the corrupted section is omitted from analysis. The dip is generated by a cosine function of fixed amplitude of 1, and the length is randomly generated using <code>floor(rnorm(1, .25 * len_x, .02 * len_x))</code>, where <code>len_x</code> is the length of the linear segment.</p>
<p>Thus, to detect the valid linear segment, <code><a href="../reference/auto_rate.html">auto_rate()</a></code> will need to omit the initial non-linear segment, ignore the dip, and then pick the longer of the 2 remaining linear segments that are separated by the dip. Here we show 25 randomly-generated plots created by the method:</p>
<p><img src="performance_files/figure-html/corruptdata-1.png" width="681.6"></p>
</div>
<div id="segmented-data" class="section level3">
<h3 class="hasAnchor">
<a href="#segmented-data" class="anchor"></a>“Segmented” data</h3>
<p><code><a href="../reference/sim_data.html">sim_data(method = "segmented")</a></code></p>
<p>Same as <code>"default"</code>, but the data is modified to contain two linear segments. The slope of the second linear segment is randomly chosen at approximately 0.5<span class="math inline">\(\times\)</span> to 0.6<span class="math inline">\(\times\)</span> of the first linear segment (i.e the slope is always a magnitude smaller than the first linear segment).</p>
<p>Thus, to detect the correct linear segment, <code><a href="../reference/auto_rate.html">auto_rate()</a></code> would need to correctly omit the initial non-linear segment, and also, ignore the end segment of the data as it has a different slope. Here we show 25 randomly-generated plots created by the method:</p>
<p><img src="performance_files/figure-html/segdata-1.png" width="681.6"></p>
</div>
</div>
<div id="test-conditions" class="section level2">
<h2 class="hasAnchor">
<a href="#test-conditions" class="anchor"></a>Test conditions</h2>
<p>To quantify the performance and accuracy of <code><a href="../reference/auto_rate.html">auto_rate()</a></code>’s linear detection technique, the function <code><a href="../reference/test_lin.html">test_lin()</a></code> runs the linear detection technique (<code>method = "linear"</code>) iteratively and extracts specific output parameter for analysis. The parameters include:</p>
<ol style="list-style-type: decimal">
<li>The length of the true segment (<span class="math inline">\(len_t\)</span>);</li>
<li>The length of the detected segment that is correctly sampled (<span class="math inline">\(len_c\)</span>). Here, we also call such data “true”;</li>
<li>The length of the detected segment that is <em>incorrectly</em> sampled (<span class="math inline">\(len_i\)</span>). Here, we also call such data “other”;</li>
<li>The slope of the true segment (<span class="math inline">\(\beta_{true}\)</span>; or true rate); and</li>
<li>The slope of the detected segment (<span class="math inline">\(\beta_{detected}\)</span>, or detected rate).</li>
</ol>
<p>From the above data, we can generate four kinds of performance metrics for visualisation:</p>
<ol style="list-style-type: decimal">
<li>A density plot of the proportion of the linear segment correctly identified. Each data point is a measure of <span class="math inline">\({len_c}\div{len_t}\)</span>.</li>
<li>A density plot of the proportion of incorrectly-sampled data. Each data point is a measure of <span class="math inline">\({len_i}\div{len_c}\)</span>.</li>
<li>A linear regression plot, where each data point is a measure of of <span class="math inline">\(\beta_{detected}\)</span> (y) as a function of <span class="math inline">\(\beta_{true}\)</span> (x);</li>
<li>An x-y plot of the deviation between <span class="math inline">\(\beta_{detected}\)</span> and <span class="math inline">\(\beta_{true}\)</span>. Each data point is a measure of <span class="math inline">\(\beta_{true} - \beta_{detected}\)</span>.</li>
</ol>
<p>We performed <code><a href="../reference/test_lin.html">test_lin()</a></code> with 1,000 iterations, for all of the three kinds of data produced by <code><a href="../reference/sim_data.html">sim_data()</a></code> (<code>"default", "corrupted"</code>, and <code>"segmented"</code>). To check performance on different data lengths, we repeated the tests using 100, 200 and 500 data points. The output of our performance test is avaliable from within the package as a data object called <code>test_lin_data</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># </span><span class="al">NOTE</span><span class="co">: Functions take some time to run</span>

<span class="co"># Test on data of length 100 samples -------------------------------------------</span>
<span class="co"># This performs 1,000 iterations of auto_rate on a "default"-type data</span>
<span class="kw">set.seed</span>(<span class="dv">123</span>)
default100 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/test_lin.html">test_lin</a></span>(<span class="dt">reps =</span> <span class="dv">1000</span>, <span class="dt">len =</span> <span class="dv">100</span>, <span class="dt">type =</span> <span class="st">"default"</span>)

<span class="co"># This performs 1,000 iterations of auto_rate on a "corrupted"-type data</span>
<span class="kw">set.seed</span>(<span class="dv">456</span>)
corrupted100 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/test_lin.html">test_lin</a></span>(<span class="dt">reps =</span> <span class="dv">1000</span>, <span class="dt">len =</span> <span class="dv">100</span>, <span class="dt">type =</span> <span class="st">"corrupted"</span>)

<span class="co"># This performs 1,000 iterations of auto_rate on a "segmented"-type data</span>
<span class="kw">set.seed</span>(<span class="dv">789</span>)
segmented100 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/test_lin.html">test_lin</a></span>(<span class="dt">reps =</span> <span class="dv">1000</span>, <span class="dt">len =</span> <span class="dv">100</span>, <span class="dt">type =</span> <span class="st">"segmented"</span>)

<span class="co"># Test on data of length 200 samples -------------------------------------------</span>
<span class="co"># This performs 1,000 iterations of auto_rate on a "default"-type data</span>
<span class="kw">set.seed</span>(<span class="dv">123</span>)
default200 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/test_lin.html">test_lin</a></span>(<span class="dt">reps =</span> <span class="dv">1000</span>, <span class="dt">len =</span> <span class="dv">200</span>, <span class="dt">type =</span> <span class="st">"default"</span>)

<span class="co"># This performs 1,000 iterations of auto_rate on a "corrupted"-type data</span>
<span class="kw">set.seed</span>(<span class="dv">456</span>)
corrupted200 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/test_lin.html">test_lin</a></span>(<span class="dt">reps =</span> <span class="dv">1000</span>, <span class="dt">len =</span> <span class="dv">200</span>, <span class="dt">type =</span> <span class="st">"corrupted"</span>)

<span class="co"># This performs 1,000 iterations of auto_rate on a "segmented"-type data</span>
<span class="kw">set.seed</span>(<span class="dv">789</span>)
segmented200 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/test_lin.html">test_lin</a></span>(<span class="dt">reps =</span> <span class="dv">1000</span>, <span class="dt">len =</span> <span class="dv">200</span>, <span class="dt">type =</span> <span class="st">"segmented"</span>)

<span class="co"># Test on data of length 500 samples -------------------------------------------</span>
<span class="co"># This performs 1,000 iterations of auto_rate on a "default"-type data</span>
<span class="kw">set.seed</span>(<span class="dv">123</span>)
default500 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/test_lin.html">test_lin</a></span>(<span class="dt">reps =</span> <span class="dv">1000</span>, <span class="dt">len =</span> <span class="dv">500</span>, <span class="dt">type =</span> <span class="st">"default"</span>)

<span class="co"># This performs 100 iterations of auto_rate on a "corrupted"-type data</span>
<span class="kw">set.seed</span>(<span class="dv">456</span>)
corrupted500 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/test_lin.html">test_lin</a></span>(<span class="dt">reps =</span> <span class="dv">1000</span>, <span class="dt">len =</span> <span class="dv">500</span>, <span class="dt">type =</span> <span class="st">"corrupted"</span>)

<span class="co"># This performs 100 iterations of auto_rate on a "segmented"-type data</span>
<span class="kw">set.seed</span>(<span class="dv">789</span>)
segmented500 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/test_lin.html">test_lin</a></span>(<span class="dt">reps =</span> <span class="dv">1000</span>, <span class="dt">len =</span> <span class="dv">500</span>, <span class="dt">type =</span> <span class="st">"segmented"</span>)</code></pre></div>
</div>
<div id="how-do-i-know-if-the-tests-are-actually-running-and-detecting-segments" class="section level2">
<h2 class="hasAnchor">
<a href="#how-do-i-know-if-the-tests-are-actually-running-and-detecting-segments" class="anchor"></a>How do I know if the tests are actually running and detecting segments?</h2>
<p><code><a href="../reference/test_lin.html">test_lin()</a></code> can perform tests in a very cool and visual way – at the cost of speed. The argument <code>plot</code>, when set to TRUE, can show us exactly the detected segments at every iteration. Try it!</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Try this code below. </span><span class="al">WARNING</span><span class="co">: Will run and plot visuals 20 times.</span>
x &lt;-<span class="st"> </span><span class="kw"><a href="../reference/test_lin.html">test_lin</a></span>(<span class="dt">reps =</span> <span class="dv">20</span>, <span class="dt">len =</span> <span class="dv">500</span>, <span class="dt">type =</span> <span class="st">"segmented"</span>, <span class="dt">plot =</span> <span class="ot">TRUE</span>)</code></pre></div>
</div>
<div id="results" class="section level2">
<h2 class="hasAnchor">
<a href="#results" class="anchor"></a>Results</h2>
<div id="default-data-1" class="section level3">
<h3 class="hasAnchor">
<a href="#default-data-1" class="anchor"></a>“Default” data</h3>
<p>Results were generally positive; when run on data with 100 samples, <strong>(A)</strong> <code><a href="../reference/auto_rate.html">auto_rate()</a></code> correctly detected a large proportion of the true segment in general, and <strong>(B)</strong> incorrectly sampled only a small amount of other data. <strong>(C)</strong> Comparison of <span class="math inline">\(\beta_{detected}\)</span> against <span class="math inline">\(\beta_{true}\)</span> showed very stable detection across all slopes, even when slope values approached zero. This was evident in <strong>(D)</strong> where roughly, the maximum <span class="math inline">\(\beta_{detected}\)</span> values had <span class="math inline">\(\pm 0.004\)</span> deviation from the <span class="math inline">\(\beta_{detected}\)</span> values across all values of <span class="math inline">\(\pm 0.06\)</span>, even for values close to zero:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(test_lin_data<span class="op">$</span>default100)</code></pre></div>
<p><img src="performance_files/figure-html/plotdefault100-1.png" width="681.6"></p>
<p>Tests on larger sample data sizes of 200 and 500 revealed that <code><a href="../reference/auto_rate.html">auto_rate()</a></code> performed better when provided with bigger data. When used on data with 500 samples, <code><a href="../reference/auto_rate.html">auto_rate()</a></code> generally <strong>(A)</strong> detected a larger proportion of the true data and <strong>(B)</strong> was less prone to sampling incorrect portions of the data. <strong>(C)</strong> Linear regression had a <span class="math inline">\(R^2\)</span> of 0.999, and <strong>(D)</strong> deviation was 10<span class="math inline">\(\times\)</span> smaller than when sample size was at 100:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(test_lin_data<span class="op">$</span>default500)</code></pre></div>
<p><img src="performance_files/figure-html/plotdefault500-1.png" width="681.6"></p>
</div>
<div id="corrupted-data-1" class="section level3">
<h3 class="hasAnchor">
<a href="#corrupted-data-1" class="anchor"></a>“Corrupted” data</h3>
<p>In this challenging data scenario <code><a href="../reference/auto_rate.html">auto_rate()</a></code> had a tendency to under-sample the linear segment. As this particular type of data consisted of two linear segments separated by a “dip”, the function also sometimes <strong>(A)</strong> detected the shorter segment as the top-ranked result, resulting in the correct estimate of <span class="math inline">\(\beta_{true}\)</span>, but the wrong linear segment detected. Thus, the function may incorrectly sample none of the linear segment <strong>(B)</strong>, but only rarely; in most cases, it still identified the right segment, and incorrectly sampled only a small amount of data. <strong>(C)</strong> Comparison of <span class="math inline">\(\beta_{detected}\)</span> against <span class="math inline">\(\beta_{true}\)</span> showed stable, but relatively noisy detection of the true rate across all slopes when compared to its performance with “default”-type data. <strong>(D)</strong> The deviation plot showed that performance was genrally poorer at values close to zero.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(test_lin_data<span class="op">$</span>corrupted100)</code></pre></div>
<p><img src="performance_files/figure-html/plotcorrupted100-1.png" width="681.6"></p>
<p>Again, <code><a href="../reference/auto_rate.html">auto_rate()</a></code> performed better when provided with bigger data. At 500 samples the same issue where the the shorter linear segment was incorrectly selected still persisted <strong>(A)</strong>, but <strong>(B)</strong> the function sampled incorrect segments less often, <strong>(C)</strong> linear regression of <span class="math inline">\(\beta_{detected}\)</span> against <span class="math inline">\(\beta_{true}\)</span> had a better goodness of fit and <strong>(D)</strong> deviation values from <span class="math inline">\(\beta_{true}\)</span> were substantially smaller with seemingly fewer poor estimates when slope values approach zero.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(test_lin_data<span class="op">$</span>corrupted500)</code></pre></div>
<p><img src="performance_files/figure-html/plotcorrupted500-1.png" width="681.6"></p>
</div>
<div id="segmented-data-1" class="section level3">
<h3 class="hasAnchor">
<a href="#segmented-data-1" class="anchor"></a>“Segmented” data</h3>
<p>This type of data is the most difficult to handle as <code><a href="../reference/auto_rate.html">auto_rate()</a></code> needed to disregard the curved, but increasingly-linear top portion of the data, and also discard the slight degree of change in slope towards the end of the data. Thus, <code><a href="../reference/auto_rate.html">auto_rate()</a></code> performed well in many cases, but poorly in others. In the majority of cases, <strong>(A)</strong> when it managed to sample the linear segment, it did so for a very large fraction of the data. <strong>(B)</strong> It performed less well at avoiding incorrect sampling, since it sometimes selected the other linear segment. However, <strong>(C)</strong> the plot of <span class="math inline">\(\beta_{detected}\)</span> against <span class="math inline">\(\beta_{true}\)</span> showed that it still performed surprisingly well most of the time, despite the errors, and <strong>(D)</strong> the deviance from the true rate appeared to be poorer when slope values are closer to zero.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(test_lin_data<span class="op">$</span>segmented100)</code></pre></div>
<p><img src="performance_files/figure-html/plotsegmented100-1.png" width="681.6"></p>
<p>Again, with a larger dataset, <code><a href="../reference/auto_rate.html">auto_rate()</a></code>’s performance was substantially better. With a 500-sample dataset, many of the issues that occured in the previous test were better resolved. The function <strong>(A)</strong> correctly sampled the right segment most of the time, and rarely sampled other data or the other linear segment <strong>(B)</strong>. <strong>(C)</strong> Linear regression of <span class="math inline">\(\beta_{detected}\)</span> against <span class="math inline">\(\beta_{true}\)</span> had a <span class="math inline">\(R^2\)</span> of 0.999, and <strong>(D)</strong> deviations from <span class="math inline">\(\beta_{true}\)</span> were much smaller in magnitude.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(test_lin_data<span class="op">$</span>segmented500)</code></pre></div>
<p><img src="performance_files/figure-html/plotsegmented500-1.png" width="681.6"></p>
<p>We did not report any of the results for 200-sample size datasets, but users are free to call the data object <code>test_lin_data</code> and plot the results, or run their own analyses using the functions we provide.</p>
</div>
</div>
<div id="linear-detection-in-other-packages-and-software" class="section level2">
<h2 class="hasAnchor">
<a href="#linear-detection-in-other-packages-and-software" class="anchor"></a>Linear detection in other packages and software</h2>
<p>To our current knowledge, one other software, <a href="https://colin-olito.github.io/LoLinR/vignettes/LoLinR.html"><code>LoLinR</code></a> (Olito et al. 2017), an R package, performs linear detection techniques on serial data. <!-- This is not a coincidence - many of the data reporting and visualisations of `auto_rate()` are, in fact, inspired by our own experiences with LoLinR.  --> <!-- However, we created the function with a completely different aim in mind (i.e. to be a part of a larger ecosystem of respirometry analysis), of which linear data detection is but one of many features availabe.  --> <!-- LoLinR is focused on one task: obtaining the best-fit linear segments from any serial data.  --> <!-- The design of our package however also allows the auto_rate function to be applied to any serial data, not just respirometry data.  --> Here, we list some very important differences between <code><a href="../reference/auto_rate.html">auto_rate()</a></code>’s linear detection method and <code>LoLinR</code>’s:</p>
<ol style="list-style-type: decimal">
<li>
<code><a href="../reference/auto_rate.html">auto_rate()</a></code> detects linear segments first before running linear regressions on the data. <code>LoLinR</code>, in contrast, performs all possible linear regressions on the data first, before implementing a ranking algorithm to rank all linear segment(s). We have discussed <code><a href="../reference/auto_rate.html">auto_rate()</a></code>’s advantages and pitfalls in this document; users are encouraged to also view <code>LoLinR</code>’s online vignette <a href="https://github.com/colin-olito/LoLinR">here</a>, and their paper linked in their document, which includes benchmark results.</li>
<li>
<code>LoLinR</code>’s algorithms uses three different metrics to select linear data, in which at least one performs very well to detect linear segments – even if a small amount data is provided (&lt;100 samples). In comparison, <code><a href="../reference/auto_rate.html">auto_rate()</a></code> performs less accurately at such small sample sizes, but that accuracy increases greatly with more data available.</li>
<li>
<code><a href="../reference/auto_rate.html">auto_rate()</a></code> is blazingly <em>fast</em>, even as it performs hundreds to thousands of rolling regressions at a time. It is perhaps ideal for large data, while LoLinR might be the function of choice for smaller datasets since its speed decreases exponentially as data gets bigger. If processing time is not an issue, users may still use <code>LoLinR</code> to analyse bigger data. Users may also find use in utilising <code>LoLinR</code>’s <code>thinData()</code> function to deal with big datasets.</li>
</ol>
</div>
<div id="references" class="section level2">
<h2 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h2>
<p>Olito, C., White, C. R., Marshall, D. J., &amp; Barneche, D. R. (2017). Estimating monotonic rates from biological data using local linear regression. The Journal of Experimental Biology, jeb.148775-jeb.148775. <a href="doi:10.1242/jeb.148775" class="uri">doi:10.1242/jeb.148775</a></p>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#testing-the-linear-detection-method-of-auto_rate">Testing the linear detection method of auto_rate</a></li>
      <li><a href="#generating-simulated-data-for-tests">Generating simulated data for tests</a></li>
      <li><a href="#test-conditions">Test conditions</a></li>
      <li><a href="#how-do-i-know-if-the-tests-are-actually-running-and-detecting-segments">How do I know if the tests are actually running and detecting segments?</a></li>
      <li><a href="#results">Results</a></li>
      <li><a href="#linear-detection-in-other-packages-and-software">Linear detection in other packages and software</a></li>
      <li><a href="#references">References</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Januar Harianto, Nicholas Carey.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
