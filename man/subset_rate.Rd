% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/subset_rate.R
\name{subset_rate}
\alias{subset_rate}
\title{Subset auto_rate results based on a range of criteria}
\usage{
subset_rate(x, method = NULL, n = NULL, plot = TRUE)
}
\arguments{
\item{x}{list. An object of class \code{auto_rate} or \code{auto_rate_subset}.}

\item{method}{string. Method by which to subset rate results. Matching results
are \emph{retained} in the output. See Details.}

\item{n}{numeric. Number, percentile, or range of results to return depending
on \code{method}. See Details.}

\item{plot}{logical. Plots a summary of subset locations within data (up to a
maximum of the first 9 ranked plots).}
}
\value{
The output of \code{subset_rate} is a \code{list} object which retains the
\code{auto_rate} class, but has an additional \code{auto_rate_subset} class. It
contains two additional elements: \verb{$original} contains the original,
unaltered \code{auto_rate} object, which will be retained through multiple
subsetting operations, that is even after processing through the function
multiple times. \verb{$subset_calls} contains the calls for every subsetting
operation that has been applied to the \verb{$original} object, from the first to
the most recent. Note, if using \verb{\%>\%} piping the \code{x} input in these appears
as \code{x = .} where it has been piped from the previous call. These additional
elements ensure the output contains the complete, reproducible history of
the \code{uato_rate} object having been subset.
}
\description{
The \code{auto_rate} function is a very powerful function, but the
output can be large and difficult to explore. \code{subset_rate} subsets
\code{auto_rate} results according to various criteria. For example, extracting
only positive or negative rates, or only the highest or lowest rates.

Note: when choosing a \code{method}, keep in mind that to keep mathematically
consistent, \code{respR} outputs oxygen consumption (i.e. respiration) rates as
negative values. This is particularly important in the difference between
\code{highest/lowest} and \code{min/max} methods.

When a \verb{$rate} is omitted by the subsetting criteria, all associated data in
\verb{$summary} (i.e. the associated row) is removed. Summary results are not
reordered in any way, only the non-matching rates removed. The \verb{$peaks} and
\verb{$metadata$no_peaks} components of the \code{auto_rate} object are similarly
adjusted. The resulting object retains the \code{auto_rate} class, however an
additional \code{auto_rate_subset} class is applied. The original \code{auto_rate}
object is saved in the output as \verb{$original}.

Multiple subsetting criteria can be applied by assigning outputs and
processing them through the function multiple times with different criteria,
or via \verb{\%>\%} piping. See examples.
}
\details{
These are the current methods by which rates in \code{auto_rate} objects
can be subset:

\subsection{ }{\code{positive}, \code{negative}} Subsets all \code{positive} (>0) or
\code{negative} (<0) rates. \code{n} is ignored. Useful in intermittent respirometry
where \code{auto_rate} may identify linear regions of oxygen increase during
flushes. Note, to keep mathematically consistent, \code{respR} outputs oxygen
consumption (i.e. respiration) rates as negative values.

\subsection{ }{\code{nonzero}, \code{zero}} Retains all \code{nonzero} rates (i.e. removes
any zero rates), or retains \emph{only} \code{zero} rates (i.e. removes all rates with
any value). \code{n} is ignored.

\subsection{ }{\code{lowest}, \code{highest}} Special note should be taken of these
methods. They can only be used when rates all have the same sign (i.e. are
all negative or all positive). Here, they subset the highest and lowest
\emph{\strong{absolute}} rate values. That is, if rates are all negative, \code{method = 'highest'} will retain the highest magnitude rates regardless of sign, that
is the \emph{most negative}. Essentially, these options ignore the sign of the
rate. \code{n} indicates how many of the lowest/highest rates to retain See \code{min}
and \code{max} options for extracting numerical low/high rates.

\subsection{ }{\code{lowest_percentile}, \code{highest_percentile}} Again, special
note should be taken of these methods, which can only be used when rates all
have the same sign (i.e. all negative or all positive). These methods retain
the \code{n}'th lowest or highest percentile of \emph{\strong{absolute}} rate values. That
is, if rates are all negative, \code{method = 'highest_percentile'} will retain
the highest \code{n}'th percentile of rates regardless of sign, that is the \emph{most
negative}. Essentially, these options ignore the sign of the rate. Here \code{n}
should be a percentile value between 0 and 1. For example, to extract the
lowest 10th percentile of rates regardless of sign, you would enter \verb{method = 'lowest_percentile', n = 0.1}.

\subsection{ }{\code{min}, \code{max}} In contrast to \code{lowest} and \code{highest}, these
are \emph{strictly numerical} options which take full account of the sign of the
rate, and can be used where rates are a mix of positive and negative. That
is, \code{method = 'min'} will retain the minimum value numerical rates,
including the most negative. \code{n} indicates how many of the min/max rates to
retain.

\subsection{ }{\code{min_percentile}, \code{max_percentile}} Like \code{min} and \code{max}
these are \emph{strictly numerical} inputs which retain the \code{n}'th minimum or
maximum percentile of the rates and take full account of the sign. Here \code{n}
should be a percentile value between 0 and 1. For example, if rates are all
negative (i.e. typical uptake rates), to extract the lowest 10th percentile
of rates, you would enter \verb{method = 'max_percentile', n = 0.1}. This is
because the \emph{lowest} rates are the \emph{highest numerically} (\code{highest/lowest}
percentile methods would be a better option in this case however).

\subsection{ }{\code{rate}, \code{rsq}, \code{row}, \code{time}} These methods work on the
respective columns of the \code{auto_rate} \verb{$summary} data frame. For these, \code{n}
should be a numeric vector of two values. Matching rows which fall within
that range (inclusive) are returned. For example, to retain only rows where
rate is between 0.05 and 0.08: \verb{method = 'rate', n = c(0.05, 0.08)}. To
retain all rates with a R-Squared above 0.90: \verb{method = 'rsq', n = c(0.9, 1)}. The \code{row} and \code{time} ranges refer to the original data source and can
be used to constrain results to rates from particular regions of the data
(though the better option is to \code{\link{subset_data}} prior to
analysis). Note, \code{time} is not the same as \code{duration} - see next section.

\subsection{ }{\code{duration}} This method allows subsetting of rates which
occur within a duration range. Here, \code{n} should be a numeric vector of two
values indicating the duration range you are interested in retaining. Use
this to set minimum and maximum durations in the time units of the original
data. For example, \code{n = c(0,500)} will retain only rates determined over a
maximum of 500 time units. To retain rates over a minimum duration, set this
using the minimum value plus the maximum duration (or simply infinity, e.g.
\code{n = c(500,Inf)}).

\subsection{ }{\code{manual}} This method simply allows particular rows of the
\verb{$summary} data frame to be manually selected to be retained. For example,
to keep only the first result: \verb{method = 'manual', n = 1}. To keep multiple
columns use regular \code{R} selection syntax: \code{n = 1:3}, \code{n = c(1,2,3)}, \code{n = c(5,8,10)}, etc. No value of \code{n} should exceed the number of rows in the
\verb{$summary} data frame.

\subsection{ }{\code{overlap}} This method removes rates which overlap, that is,
linear regions identified by \code{auto_rate} which partly or completely share
the same rows of the data. Due to the way \code{auto_rate} works, it may identify
multiple linear regions some of which may substantially overlap, or even be
completely contained within others. In such cases taking an average of the
rate values may be questionable, as certain regions will be weighted higher
due to these multiple, overlapping results. This method removes overlapping
rates, using \code{n} as a threshold to determine degree of permitted overlap. It
is recommended this method be used after all other selection criteria have
been applied, as it is quite aggressive about removing rates, including
high-ranked ones, and can be computationally intensive when there are many
results. It can also only be used on \code{auto_rate} objects where the \code{linear}
method has been used (the others specifically output all overlapping
(\code{min/max}) or non-overlapping (\code{interval}) rates). Permitted overlap is
determined by \code{n}, which indicates the minimum proportion of each particular
regression which must overlap with another for it to be regarded as
overlapping.  For example, \code{n = 0.2} means a regression would have to
overlap with another by 20\% or more of its total length to be regarded as
overlapping. The \code{overlap} method does several operations. First, any
duplicate rows in \verb{$summary} are removed. Second, any rate regressions which
are completely contained within any others are removed. Neither of these
operations uses \code{n}.

Lastly, for each \code{rate_b1} result in \verb{$summary} how many \emph{other} rate
results it overlaps with (accounting for \code{n}) is determined. The one which
overlaps with the most others is then removed. In the event of multiple
rates having the same number of overlaps, it removes the least ranked one
(i.e. lowest in the summary table). It repeats this analysis iteratively
until only non-overlapping rates (accounting for \code{n}) are retained. If \code{n = 0}, only rates which do not overlap at all are retained. If \code{n = 1}, only
duplicate rows and rates which are entirely contained within another are
removed.
}
\examples{
 ar_obj <- inspect(intermittent.rd, plot = FALSE) \%>\%
 auto_rate(plot = FALSE)
 ar_subs_neg <- subset_rate(ar_obj, method = "negative", plot = FALSE)
}
