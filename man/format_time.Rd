% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/format_time.R
\name{format_time}
\alias{format_time}
\title{Parse date-time data to numeric}
\usage{
format_time(x, time = 1, format = "ymdHMS", start = 0)
}
\arguments{
\item{x}{vector or data frame containing strings or class POSIX.ct date-time
data to be converted to numeric.}

\item{time}{numeric value or vector of length 2. Identifies column(s)
containing date-time data}

\item{format}{string. Code describing structure of date-time data. See
details. Directly relates to functions in the package \code{lubridate}}

\item{start}{numeric. Default = 0. At what time (in seconds) should the
formatted time data start?}
}
\value{
A vector or data frame, depending on input. If input is a vector, a
vector of same length containing numeric time is returned. If input is a
data frame, the output data frame is identical, except a new column,
\code{time.num},of numeric time data in seconds is added as the first column.
}
\description{
A function to parse class POSIX.ct or text strings of date-time data to
numeric time for use in \code{respR} functions.
}
\details{
\strong{Input}

Input can be a vector, or data frame. If a vector, output is a vector of
equal length containing numeric time data. If a data frame, the column index
of the date-time data can be specified using the \code{time =} input. If date-time
data is split over two columns (e.g. date in one column, time in another),
two columns can be specified. The function uses these to combine date and
time strings together for conversion. If multiple columns are specified, the
\code{format} setting should reflect the same order entered in \code{time =}. The
output data frame will be identical, except a new column called \code{time.num} is
added as the first column.

Date-time data can be unspaced or separated by any combination of spaces,
forward slashes, hyphens, dots, commas, colons, semicolons, or underscores.

E.g. all these are parsed as the same date-time: \code{"2010-02-28 13:10:23", "20100228131023", "2010,02/28 13.10;23", "2010 02 28 13_10-23"}.
\itemize{
\item Times can be in 24H or 12H with AM/PM \cr E.g. "2010-02-28 13:10:23" or
"2010-02-28 1:10:23 PM"
\item Times without initial zero are parsed as 24H time \cr E.g. "1:10:23" is
same as "1:10:23 AM" or "01:10:23"
\item AM/PM take precedence over 24H formatting for 01-12h \cr E.g. "1:10:23 PM"
and "01:10:23 PM" are both same as "13:10:23"
\item However, 24H formatting for 13-24h takes precedence over AM/PM \cr E.g.
"13:10:23 AM" is identified as "1:10:23 PM" or "13:10:23"
}

Regardless of input, all data are parsed to numeric time data in seconds
duration from the first entry, unless a \code{start} number is specified, in which
case the series starts at that number (in seconds) and all subsequent times
are shifted forward by the same amount.

\strong{Syntax}

Simply identify the order which the year, month, day, and time appears in
your date-time input.

\describe{ \item{\code{d}}{Day of the month as decimal number (01--31 or 0--31).}
\item{\code{m}}{Month of the year as decimal number (01--12 or 1--12).}
\item{\code{y}}{Year (2010, 2001, 1989).} \item{\code{H}}{Hour, must be capitalised
(\code{H}, not \code{h}). Decimal number (00--24 or 0--24).} \item{\code{M}}{Minute, must be
capitalised (\code{M}, not \code{m}). Decimal number (00--59 or 0--59).}
\item{\code{S}}{Second, must be capitalised (\code{S}, not \code{s}). Decimal number (00--59
or 0--59).} \item{\code{p}}{AM/PM indicator. Adding this will format the data as
12-h date-time format.} }

Print the order in the \code{format} string argument, using separators if you
choose to (optional): \code{"dmyHMS"}; \code{"dmy_HMS"} and \code{"d m y H M S"} are all the
same. Obviously, single experiments will not be conducted across different
time zones, so if a time zone is present, it is ignored for the purposes of
calculating numeric times. If multiple columns have been specified in the
\code{time} argument, the \code{format} should reflect the same order.
}
\examples{
# convert year-month-day hour-min-sec
x <- c("09-02-03 01:11:11", "09-02-03 02:11:11","09-02-03 02:25:11")
format_time(x)
## [1]    0 3600 4440

# convert day-month-year hour-min
x <- c("03-02-09 01:11", "03-02-09 02:11","03-02-09 02:25")
format_time(x, format = "dmyHM")
## [1]    0 3600 4440

# convert when AM/PM is present
x <- c("09-02-03 11:11:11 AM", "09-02-03 12:11:11 PM","09-02-03 01:25:11 PM")
format_time(x, format = "dmyHMS") # this is wrong
format_time(x, format = "dmyHMSp")
## [1]    0 3600 8040

# convert dataframe with year-month-day hour-min-sec (ymdHMS default)
x <- data.frame(
  x = c("09-02-03 01:11:11", "09-02-03 02:11:11","09-02-03 02:25:11"),
  y = c(23, 34, 45))
format_time(x, time = 1)

# convert dataframe with time in different column and non-default format
x <- data.frame(
  x = c(23, 34, 45),
  y = c("09-02-2018 11:11:11 AM", "09-02-2018 12:11:11 PM","09-02-2018 01:25:11 PM"),
  z = c(56, 67, 78))
format_time(x, time = 2, format = "dmyHMSp")

# convert dataframe with separate date and time columns crossing midnight
x <- data.frame(
  w = c("09-02-18", "09-02-18","10-02-18"),
  x = c("22:11:11", "23:11:11","00:25:11"),
  y = c(23, 34, 45),
  z = c(56, 67, 78))
format_time(x, time = 2, format = "HMS") # WRONG! Crosses midnight
format_time(x, time = c(1,2), format = "dmyHMS") # Correct
format_time(x, time = c(2,1), format = "HMSdmy") # Different column order & format
}
\seealso{
\code{\link{lubridate}}
}
