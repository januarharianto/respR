---
title: "`auto_rate()`"
output:
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{automation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = F, warning = F, message = F}
library(knitr) # load knitr to enable options
library(respR) # load respR
# library(dplyr) # for some piping exercises
# library(DiagrammeR) # flowcharts... and more

opts_chunk$set(collapse = TRUE, comment = "#>", cache = FALSE,
  highlight = TRUE, fig.width = 7.1, fig.height = 6)
```

## Introduction

The function `auto_rate()` uses rolling regression techniques to automatically estimate the *maximum*, *minimum*, *interval* rate, or the *most linear* sections of an oxygen time-series over a specific sampling window. 
In addition, when used to detect linear sections of the data, a **kernel density estimate** is performed on the rolling regression output and the **kernel bandwidth** used to re-sample linear regions of the data for re-analysis. 

<!-- The diagram below illustrates the main processes involved in producing the different outputs of the function: -->

<!-- ### Working in the Tidyverse -->

<!-- `respR` integrates nicely in the [Tidyverse](https://www.tidyverse.org/), specifically with `dplyr` functions e.g. `select()`, `filter()` and `mutate()`, and `magrittr` pipe operators ("`%>%`") to clearly express workflows in an organised sequence. For more information about using pipes in particular, see the ["Pipes" chapter](http://r4ds.had.co.nz/pipes.html) in the online R for Data Science book. -->

<!-- We load the data, `sardine.rd`, which contains approximately 2.1 hours (7,513 data points) of a single respirometry experiment. -->

<!-- ```{r} -->
<!-- library(respR) -->
<!-- data("sardine.rd") -->
<!-- ?sardine.rd # run this to see notes about the dataset -->
<!-- ``` -->


<!-- ```{r, echo = F} -->
<!-- library(DiagrammeR) -->
<!-- grViz(" -->
<!-- digraph a_nice_graph { -->

<!-- # node definitions with substituted label text -->

<!-- node [fontname = Helvetica, shape = circle]         -->
<!-- rd [label = 'Raw Data'] -->

<!-- node [fontname = Helvetica, shape = rectangle]         -->
<!-- rr [label = '1. Rolling linear regression'] -->
<!-- kd [label = '2. Kernel density\nestimates'] -->
<!-- re [label = '3. Bin resampling'] -->
<!-- lr [label = '4. Linear regression'] -->
<!-- ar [label = '5. Rank'] -->
<!-- fi [label = '6. Filter'] -->

<!-- node [fontname = Menlo, shape = none] -->
<!-- au [label = 'auto_rate()'] -->
<!-- li [label = 'linear'] -->
<!-- mm [label = 'max, min'] -->
<!-- in [label = 'interval'] -->

<!-- # edge definitions with the node IDs -->

<!-- rd -> au -> rr -> ar -> mm -->
<!-- rr -> kd -> re -> lr -> ar -> li -->
<!-- rr -> fi -> in -->

<!-- }") -->
<!-- ``` -->


## Rolling linear regression

Regardless of the method called, `auto_rate()` always performs a rolling linear regression on the data before additional methods are applied. 
The rolling regression runs all possible ordinary least-squares (OLS) linear regressions $(y = \beta_0 + \beta_1 X + \epsilon)$ of a fixed sample width across the entire data series, and is expressed as: $$y_t(n) = X_t(n) \beta (n) + \epsilon_t(n), \ t = n,\ ...,\ T$$ where $n$ is the window of width $n < T$, $T$ is the total length of the dataset, $y_t(n)$ is the vector of observations on the response, $X_t(n)$ is the matrix of explanatory variables, $\beta (n)$ is a vector of regression paramters and $\epsilon_t(n)$ is a vector of error terms. 

To determine the maximum or minimum rate in the data series, no further transformation of the data is necessary. 
All possible fixed-width regressions have been captured and ranked by size to accurately determine those values.
The interval rate is also obtained by filtering the rolling regressions at specific time or row intervals.

## Kernel density estimation 

Additional methods are automatically applied when we use `auto_rate()` to detect linear sections of the data. 
First, a Gaussian kernel density estimate (KDE) is used to process the regression coefficient $\beta$, based on the key assumption that linear sections of the data are reflected by relatively stable parameters across the rolling estimates.
This assumption is used often in financial statistics to evaluate stability and make predictions on time-series data.
Here, KDE automatically aggregates stable (i.e. linear) sections as they naturally form one or more local maximums ("modes") in the probability density estimate, and if the distribution is multimodal, the modes are ranked by size.

KDE requires no assumption that the data is from a parametric family, and learns the shape of the density automatically without supervision.
KDE can be expressed as: $$\hat{f}(x) = \frac{1}{nh^d}\sum_{i = 1}^{n} K \left(\frac{x - X_i}{h} \right)$$ where $f$ is the density function from an unknown distribution $P$ for $X_1,...,X_n$, $K$ is the kernel function and $h$ is the optimal smoothing bandwidth.
The smoothing bandwidth $h$ is computed using an adjusted kernel bandwidth selector based on Silvermans "rule of thumb" (Silverman, 1986): $$h = \left(\frac{4\hat{\sigma}^5}{3n} \right)^{\frac{1}{5}} \approx 1.06\hat{\sigma}n^{-\frac{1}{5}}$$ where $\hat{\sigma}$ is the standard deviation of the samples and $n$ is the total number of samples. 

Using the parameter $h$, it is possible to group rolling parameters that determine each mode of the density estimate ($mode \pm 0.5h$).
Grouped rolling estimates with overlapping windows are merged and the re-constructed windows are re-analysed using linear regression, then saved in the output.

## Adjusting the width of rolling regressions

By default, `auto_rate()`'s rolling regression uses a rolling window value of `0.2` multiplied by the total length of the number of samples, or total time elapsed. This can be changed by changing the `width` argument, to a proportion (`width = 0.1`) or a fixed number (`width = 3000`). The `width` argument also determines the minimum window size of the linear data obtained, but does not have any control over the maximum window size as that is determined by KDE.

## Examples

The function `auto_rate()` performs automatic detection of linear data by default:

```{r}
auto_rate(sardine.rd)
```


We can customise the rolling window size and type by adding the `width` and `by` arguments. Note that using time-based rolling regression takes a bit more processing time: 
```{r}
auto_rate(sardine.rd, width = 2500, by = "time")
```



<!-- ## Comparison to other methods and packages {#compare} -->



