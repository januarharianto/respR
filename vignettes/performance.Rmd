---
title: "Assessing the performance of respR's auto_rate function in detecting 
  linear data"
output:
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{autorate_performance}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, echo = F, warning = F, message = F}
library(knitr) # load knitr to enable options
library(respR) # load respR

opts_chunk$set(collapse = TRUE, comment = "#>", cache = FALSE,
  highlight = TRUE, fig.width = 7.1, fig.height = 6)
```


The function `auto_rate()` uses rolling regression and kernel density estimation techniques to automatically detect the most linear sections of respirometry data. 
The dimensionless nature of the function, however, also allows it to be applied to any serial data. 
To our knowledge, the methods we use here are novel, and not reported in past publications involving linear data detection and analysis of biological data.
Olito et al. (2016) describes a different, though very robust, method to detect and rank linear segments in data using their R package, `LoLinR`. 
A brief comparison of `auto_rate()` and `LoLinR`'s methods are discussed at the end of this document.


## Testing the linear detection method of auto_rate

To ensure that `auto_rate()` performs as intended, we created two internal functions designed to test the accuracy of our KDE techniques to detect linear data. 
The first function, `sim_data()`, generates a random dataset which contains both linear and non-linear segments. 
The second function, `test_lin()`, specifically performs `auto_rate()` repeatedly on randomly generated data and aggregates the performance metrics obtained to assess and visualise the accuracy of the KDE technique.
Both functions are published with the `respR` package, thus anyone can use them -- as we show below -- or run them with their own input paramters.

The performance tests that we provide are by no means comprehensive, but provide a starting point in generating the data necessary for users to make informed decisions on using and further testing `auto_rate()` for their own purposes.


## Generating simulated data for tests

`sim_data()` is used to randomly generate three kinds of data based on the `method` argument, which we briefly describe below. 
It accepts inputs to customise the length of the data (no. of samples), the type of data (described below), the degree of noise ad specified by the standard deviation of the data (default 0.05), and a preview toggle to plot and visualise the simulated dataset.

### "Default" data

`sim_data(method = "default")`

A non-linear segment is first generated using a sine or cosine function with a random length of `floor(abs(rnorm(1, .25*len, .05*len)))`, where `len` is the total number of observations in the data defined in the function argument, and a random amplitude of `rnorm(1, .8, .05)`. 
This data segment is appended to a linear segment with a randomly-generated slope computed using `rnorm(1, 0, 0.02)`.
The shape of the dataset is designed to mimic common respirometry data whereby the initial sections of the data are often non-linear. 
Here we show 25 randomly-generated plots created by the method:

```{r defaultdata, echo=F, results='hide'}
set.seed(117)
pardefault <- par(no.readonly = T)  # save original par settings
par(mfrow = c(5, 5), mai=c(.2,.2,0,0), oma = c(2,2,1,1), ps = 8, cex = 1,
  cex.main = 1)
# set.seed(990)
replicate(25, sim_data(len = 100, type = "default"))
pardefault
```

### "Corrupted" data

`sim_data(method = "corrupted")`

Same as `"default"`, but "corrupted" data is inserted randomly at any point in the linear segment.
The data corruption is depicted by a sudden dip in the reading, which recovers. 
This event mimics equipment interference that does not necessarily invalidate the dataset if the corrupted section is omitted from analysis. 
The dip is generated by a cosine function of fixed amplitude of 1, and the length is randomly generated using `floor(rnorm(1, .25 * len_x, .02 * len_x))`, where `len_x` is the length of the linear segment.

Thus, to detect the valid linear segment, `auto_rate()` will need to omit the initial non-linear segment, ignore the dip, and then pick the longer of the 2 remaining linear segments that are separated by the dip.
Here we show 25 randomly-generated plots created by the method:

```{r corruptdata, echo=F, results='hide'}
set.seed(654)
pardefault <- par(no.readonly = T)  # save original par settings
par(mfrow = c(5, 5), mai=c(.2,.2,0,0), oma = c(2,2,1,1), ps = 8, cex = 1,
  cex.main = 1)
# set.seed(880)
replicate(25, sim_data(len = 100, type = "corrupted"))
pardefault
```

### "Segmented" data

`sim_data(method = "segmented")`

Same as `"default"`, but the data is modified to contain two linear segments. 
The slope of the second linear segment is randomly chosen at approximately 0.5$\times$ to 0.6$\times$ of the first linear segment (i.e the slope is always a magnitude smaller than the first linear segment). 

Thus, to detect the correct linear segment, `auto_rate()` would need to correctly omit the initial non-linear segment, and also, not sample the end segment of the data as it has a different slope.
Here we show 25 randomly-generated plots created by the method:

```{r segdata, echo=F, results='hide'}
set.seed(291)
pardefault <- par(no.readonly = T)  # save original par settings
par(mfrow = c(5, 5), mai=c(.2,.2,0,0), oma = c(2,2,1,1), ps = 8, cex = 1,
  cex.main = 1)
# set.seed(880)
replicate(25, sim_data(len = 100, type = "segmented"))
pardefault
```

## Test conditions

To quantify the performance and accuracy of `auto_rate()`'s linear detection technique, the function `test_lin()` runs the linear detection technique (`method = "linear"`) iteratively and extracts specific output parameter for analysis.
The parameters include: 

1. The length of the true segment ($len_t$);
2. The length of the detected segment that is correctly sampled ($len_c$). Here, we also call such data "true";
4. The length of the detected segment that is *incorrectly* sampled ($len_i$). Here, we also call such data "other";
5. The slope of the true segment ($\beta_{true}$; or true rate); and
6. The slope of the detected segment ($\beta_{detected}, or detected rate$).

From the above data, we can generate four kinds of performance metrics for visualisation: 

1. A density plot of the proportion of the linear segment correctly identified. Each data point is a measure of ${len_c}\div{len_t}$.
2. A density plot of the proportion of incorrectly-sampled data. Each data point is a measure of ${len_i}\div{len_c}$.
3. A linear regression plot, where each data point is a measure of of $\beta_{detected}$ (y) as a function of $\beta_{true}$ (x);
4. An x-y plot of the deviation between $\beta_{detected}$ and $\beta_{true}$. Each data point is a measure of $\beta_{true} - \beta_{detected}$.


We performed `test_lin()` with 1,000 iterations, for all of the three kinds of data produced by `sim_data()` (`"default", "corrupted"`, and `"segmented"`). 
To check performance on different data lengths, we repeated the tests using 100, 200 and 500 data points. The output of our performance test is avaliable from within the package as a data object called `test_lin_data`.

```{r benchmarks, eval = F}
# NOTE: Functions take some time to run

# Test on data of length 100 samples -------------------------------------------
# This performs 1,000 iterations of auto_rate on a "default"-type data
set.seed(123)
default100 <- test_lin(reps = 1000, len = 100, type = "default")

# This performs 1,000 iterations of auto_rate on a "corrupted"-type data
set.seed(456)
corrupted100 <- test_lin(reps = 1000, len = 100, type = "corrupted")

# This performs 1,000 iterations of auto_rate on a "segmented"-type data
set.seed(789)
segmented100 <- test_lin(reps = 1000, len = 100, type = "segmented")

# Test on data of length 200 samples -------------------------------------------
# This performs 1,000 iterations of auto_rate on a "default"-type data
set.seed(123)
default200 <- test_lin(reps = 1000, len = 200, type = "default")

# This performs 1,000 iterations of auto_rate on a "corrupted"-type data
set.seed(456)
corrupted200 <- test_lin(reps = 1000, len = 200, type = "corrupted")

# This performs 1,000 iterations of auto_rate on a "segmented"-type data
set.seed(789)
segmented200 <- test_lin(reps = 1000, len = 200, type = "segmented")

# Test on data of length 500 samples -------------------------------------------
# This performs 1,000 iterations of auto_rate on a "default"-type data
set.seed(123)
default500 <- test_lin(reps = 1000, len = 500, type = "default")

# This performs 100 iterations of auto_rate on a "corrupted"-type data
set.seed(456)
corrupted500 <- test_lin(reps = 1000, len = 500, type = "corrupted")

# This performs 100 iterations of auto_rate on a "segmented"-type data
set.seed(789)
segmented500 <- test_lin(reps = 1000, len = 500, type = "segmented")

```

## How do I know if the tests are actually running and detecting segments?

`test_lin()` can perform tests in a very cool and visual way -- at the cost of speed. The argument `plot`, when set to TRUE, can show us exactly the detected segments at every iteration. Try it!

```{r, eval=F}
# Try this code below. WARNING: Will run and plot visuals 20 times.
x <- test_lin(reps = 20, len = 500, type = "segmented", plot = TRUE)
```

## Results

<!-- Overall, `auto_rate()`'s linear detection algorithms performed relatively well across all three different data scenarios.  -->
<!-- Linear regressions results comparing $\beta_{true}$ to $\beta_{detected}$ were overwhelmingly significant (Figs 2D, 3D, 4D), with $R^2$ at 0.999 for all tests.  -->

<!-- Detecting a shorter segment of the linear data does not necessarily have a negative impact on the detected slope, but over-detection should generally be avoided since it results in an over or under-estimate the true slope.  -->
<!-- `auto_rate()` performed satisfactorily in detecting linear segments of the simulated data, and rarely oversampled the linear segments (Figs 2A, 3A).  -->
<!-- However, it oversampled more when used on "segmented" data (Fig 4A), due to the increased difficulty in correctly distinguishing both ends of the linear segment.  -->
<!-- Regardless, the oversampling was not meaningful enough to alter the calculated slopes drastically, as shown by the mostly narrow differences between $\beta_{true}$ and $\beta_{detected}$ across the datasets (Fig 4B, E) and the strong results of the linear regression analysis. -->
<!-- For "corrupted" data, there was evidence that `auto_rate()` sometimes sampled the wrong segments, or oversampled the data, resulting in the larger deviations from $\beta_{true}$ (Fig 3E). We recommend users to exercise caution when running `auto_rate()'`s linear detection on data that contains major artefacts or non-biological noise, and to always inspect the exploratory plots produced whenever they run `auto_rate()` on such data. -->

<!-- For slope values approaching zero, `auto_rate()` continued to perform well as shown by the relatively narrow distribution of $d$ across all data types tested (Figs 2E, 3E, 4E).  -->
<!-- The large \% differences between $\beta_{true}$ and $\beta_{detected}$ as the slope approached zero (Figs 1C, 2C, 3C) were expected, since minor differences in values approaching zero are greatly amplified (e.g. 0.00002 is a 100% increase from 0.00001, whereas 0.20002 is just a 0.005\% increase from 0.20001). -->
<!-- Despite the weighted influence of smaller slope values when calculating \% difference between $\beta_{true}$ and $\beta_{detected}$, detected slope values were overwhelmingly close to the known values, with more than 78\% -- 87\% of the values within 5\% of the known slopes (Figs 2C, 3C, 4C). -->

<!-- In general, `auto_rate()`'s performance was not affected whether the slope was positive, negative or approaching zero, with no visible skewness in the normal distribution of error across all data scenarios that were simulated here (Figs 2B, 3B, 4B). -->
<!-- The tests performed and the results obtained indicated that `auto_rate()`'s linear detection methods hold promise and are potentially reliable techniques, at least for the types of data simulated for this exercise. We encourage users to evaluate the function with real data and send us feedback should `auto_rate()`'s linear detection fails. -->


### "Default" data

Results were generally positive; when run on data with 100 samples, **(A)** `auto_rate()` correctly detected a large proportion of the true segment in general, and **(B)** incorrectly sampled only a small amount of other data. 
**(C)** Comparison of $\beta_{detected}$ against $\beta_{true}$ showed very stable detection across all slopes, even when slope values approached zero. 
This was evident in **(D)** where roughly, the maximum $\beta_{detected}$ values had $\pm 0.004$ deviation from the $\beta_{detected}$ values across all values of $\pm 0.06$, even for values close to zero:

```{r plotdefault100, fig.cap=""}
plot(test_lin_data$default100)
```

Tests on larger sample data sizes of 200 and 500 revealed that `auto_rate()` performed better when provided with bigger data. 
When used on data with 500 samples, `auto_rate()` generally **(A)** detected a larger proportion of the true data and **(B)** was less prone to sampling incorrect portions of the data. 
**(C)** Linear regression had a $R^2$ of 0.999, and **(D)** deviation was 10$\times$ smaller than when sample size was at 100:

```{r plotdefault500, fig.cap=""}
plot(test_lin_data$default500)
```

### "Corrupted" data

In this challenging data scenario `auto_rate()` had a tendency to under-sample the linear segment. 
As this particular type of data consisted of two linear segments separated by a "dip", the function also sometimes **(A)** detected the shorter segment as the top-ranked result, resulting in the correct estimate of $\beta_{true}$, but the wrong linear segment detected. 
Thus, the function may incorrectly sample none of the linear segment **(B)**, but only rarely; in most cases, it still identified the right segment, and incorrectly sampled only a small amount of data.
**(C)** Comparison of $\beta_{detected}$ against $\beta_{true}$ showed stable, but relatively noisy detection of the true rate across all slopes when compared to its performance with "default"-type data. 
**(D)** The deviation plot showed that performance was genrally poorer at values close to zero.

```{r plotcorrupted100, fig.cap=""}
plot(test_lin_data$corrupted100)
```

Again, `auto_rate()` performed better when provided with bigger data. At 500 samples the same issue where the the shorter linear segment was incorrectly selected still persisted **(A)**, but **(B)** the function sampled incorrect segments less often, **(C)** linear regression of $\beta_{detected}$ against $\beta_{true}$ had a better goodness of fit and **(D)** deviation values from $\beta_{true}$ were substantially smaller with seemingly fewer poor estimates when slope values approach zero. 

```{r plotcorrupted500, fig.cap=""}
plot(test_lin_data$corrupted500)
```

### "Segmented" data

This type of data is the most difficult to handle as `auto_rate()` needed to disregard the curved, but increasingly-linear top portion of the data, and also discard the slight degree of change in slope towards the end of the data. 
Thus, `auto_rate()` performed well in many cases, but poorly in others. 
In the majority of cases, **(A)** when it managed to sample the linear segment, it did so for a very large fraction of the data. 
**(B)** It performed less well at avoiding incorrect sampling, since it sometimes selected the other linear segment. 
However, **(C)** the plot of $\beta_{detected}$ against $\beta_{true}$ showed that it still performed surprisingly well most of the time, despite the errors, and **(D)** the deviance from the true rate appeared to be poorer when slope values are closer to zero.

```{r plotsegmented100, fig.cap=""}
plot(test_lin_data$segmented100)
```

Again, with a larger dataset, `auto_rate()`'s performance was substantially better. With a 500-sample dataset, many of the issues that occured in the previous test were better resolved. 
The function **(A)** correctly sampled the right segment most of the time, and rarely sampled other data or the other linear segment **(B)**. 
**(C)** Linear regression of $\beta_{detected}$ against $\beta_{true}$ had a $R^2$ of 0.999, and **(D)** deviations from $\beta_{true}$ were much smaller in magnitude.

```{r plotsegmented500, fig.cap=""}
plot(test_lin_data$segmented500)
```

We did not report any of the results for 200-sample size datasets, but users are free to call the data object `test_lin_data` and plot the results, or run their own analyses using the functions we provide.

## Linear detection in other packages and software

Currently and to our knowledge, only one other software, `LoLinR` (Olito et al. 2017), also an R package, performs linear detection techniques on serial data. 
This is not a coincidence - many of the data reporting and visualisations of `auto_rate()` are, in fact, inspired by our own experiences with LoLinR. 
However, we created the function with a completely different aim in mind (i.e. to be a part of a larger ecosystem of respirometry analysis), of which linear data detection is but one of many features availabe. 
LoLinR is focused on one task: obtaining the best-fit linear segments from any serial data. 
<!-- The design of our package however also allows the auto_rate function to be applied to any serial data, not just respirometry data.  -->
It is up to users to decide whether to use `LoLinR` or `respR'`s `auto_rate()` function for linear detection, but we list some very important differences specific only to `auto_rate()`'s linear detection method and `LoLinR`'s:

1. `auto_rate()` detects linear segments first, and then performs linear regressions on the data. `LoLinR`, in contrast, performs all possible linear regressions on the data first, before implementing a ranking algorithm to rank all linear segment(s). Thus both methods use different implementations and techniques. We have discussed `auto_rate()`'s advantages and pitfalls in this document; users are encouraged to also view `LoLinR`'s online vignette (here)[https://januarharianto.github.io/respR/reference/index.html], and their paper linked in their document, which includes benchmark results.
2. `LoLinR`'s algorithms uses three different metrics to select linear data, in which at least one performs very well to detect linear segments -- even if a small amount data is provided (<100 samples). In comparison, `auto_rate()` performs less accurately at such small sample sizes, but that accuracy increases greatly with more data available.
3. `auto_rate()` is blazingly *fast*, even as it performs hundreds to thousands of rolling regressions in some cases. It is perhaps ideal for large data, while LoLinR might be the function of choice for smaller datasets since its speed decreases exponentially as data gets bigger. If processing time is not an issue, users may still use `LoLinR` to analyse bigger data.

## References

Olito, C., White, C. R., Marshall, D. J., & Barneche, D. R. (2017). Estimating monotonic rates from biological data using local linear regression. The Journal of Experimental Biology, jeb.148775-jeb.148775. doi:10.1242/jeb.148775
