---
title: "subset_rate: Filtering auto_rate results"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{subset_rate: Filtering auto_rate results}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, echo = F}
library(knitr) # load knitr to enable options
library(respR) # load respR

opts_chunk$set(collapse = TRUE, 
               comment = "#>", 
               cache = FALSE, 
               tidy = TRUE, 
               highlight = TRUE, 
               fig.width = 10, 
               fig.height = 5,
               fig.align = "center",
               R.options = list(scipen = 999, 
                                digits = 3))
```

- include how to report language example
- don't trust linear? use rolling and apply your own criteria
- include min/max filtering  
- Can output min/max rate over time period, but sometimes this is lowest but clearly crappy. 
- See NLA1_03 rep 5 for good example

## Introduction {#adjintro}

New in `respR v2.0` is the `subset_rate()` function, which is designed to allow `auto_rate()` results to be subset and filtered.

The `auto_rate` function uses machine learning techniques to *automatically* detect the **most linear** regions of a dataset, as well as having options to fit every regression of a specified width over the entire dataset and ordering them in various ways.

As multiple linear regions are often identified, or the results object contains literally thousands of regressions, the output can be large and difficult to explore. Which of the rates are 'best' or most appropriate to report may be confusing. In addition, it may identify linear data regions, but from areas of the data that are not of experimental interest. As an advanced, machine learning based process the `linear` method is also somewhat fallible and on occasion may return questionable results.

`subset_rate` helps explore and filter `auto_rate` results by selecting rates according to various criteria. For example, extracting only positive or negative rates, only the highest or lowest rates by number or percentile, those above a particular r-squared, only those from certain data regions, and numerous other methods that allow advanced filtering of results so the rates extracted are well-defined towards the research question of interest. This allows for application of consistent rate selection criteria and reporting of results. 

Note that generally speaking, for large datasets, such as from intermittent-flow experiments, we recommend using `subset_data()` and  running `auto_rate` on the subset(s) of the data you are interested in, rather than run it on the whole dataset and relying on `subset_rate` to filter it afterwards.

## Subsetting methods

The function includes a wide array of criteria by which `auto_rate` results can be subset. The full list can be seen in the help file: `help(subset_rate)`. We will run through some specific examples below. Multiple subsetting criteria can be applied by assigning (i.e. saving) the output and processing it through the function multiple times with different criteria, or alternatively via piping (`%>%` or `|>`). See examples below. 

### Overlapping results

A notable aspect of `auto_rate` is that due to the machine learning algorithm, it can often return multiple linear regions from the same part of a dataset. These can even be identical. There is a special subsetting method to remove some or all of these. See examples below. 

## Examples

### Subsetting `method = "linear"` results

We'll use the `sardine.rd` dataset, and let's say we are interested in extracting a standard metabolic rate, that is the lowest routine rate, one which may be representative of basal of maintenance metabolism.  

We'll `inspect` the data and pipe the result to `auto_rate` using the default inputs of the `"linear"` method and `width = 0.2`.  

```{r fig.keep='last', results='hide', message=FALSE}
sard <- inspect(sardine.rd) |> 
  auto_rate() 
```

We can see there are 46 linear regions detected, of which this plot is the highest ranked one, or most linear according to the kernel density analysis. This does not necessarily mean it's the lowest rate, just the most consistently maintained one. 

Now let's print the entire summary table. 

```{r}
print(sard$summary)
```

Obviously this is a lot of information to digest. The rates, which is the primary output we are interested in, vary in value by quite a lot. The r-squared of the regressions is fairly variable. The linear regions also occur all over the dataset. 

#### plot_ar

There is a handy function `plot_ar()` which plots `auto_rate` summary tables in a way that visualises where they occur in the context of the dataset. See [later section](#plot_ar_fn) for more details about this function.

```{r results='hide'}
plot_ar(sard)
```

In this plot each regression in `$summary` is represented in the lower plot by a bar representing its location within the timeseries. The top ranked result is highest, and the y-axis represents the `rank` position within the summary table. 

From this plot the results are clearer. 

#### `subset_rate`

```{r fig.keep='last', message=FALSE, results='hide'}
sard |> 
  subset_rate(method = "overlap", n = 1) |>
  plot_ar()
```


```{r fig.keep='last', message=FALSE, results='hide'}
sard |> 
  subset_rate(method = "overlap", n = 0.9) |>
  plot_ar()
```

```{r echo = FALSE, fig.keep='none', message=FALSE}
sard |> 
  subset_rate(method = "overlap", n = 0.9, plot = FALSE) |>
  summary()
```

This is a much more manageable set of results. 

### Subsetting to get a minimum rate

We'll use the `sardine.rd` dataset again, and let's say we are interested in extracting a standard metabolic rate, that is the lowest routine rate, one which may be representative of basal of maintenance metabolism.  

There are a number of approaches we could take using a combination of `auto_rate` and `subset_rate`. Here we'll cover two of them: the first using the `linear` method and subsetting these linear regions to find the lowest, the second to run `auto_rate` with `method = "lowest"` and a fixed `width` and subset out the ones we are interested in while applying some additional criteria.

#### `method = "linear"`

We'll run `auto_rate` again on the data and 



### Intermittent flow 

By applying selective criteria `subset_rate` can also be used to extract rates from structured intermittent-flow data. 

Our ultimate aim is to extract a consistent rate from each replicate. 



## `plot_ar` function {#plot_ar_fn}

Different regressions can be highlighted using the `highlight`input, and `pos` can control which regressions are plotted (the default being all). 

```{r}
plot_ar(sard, highlight = 3, pos = 1:5)
```


### Remove duplicates

```{r}
sard$summary[9:12,]
```

```{r}
sard_sub <- subset_rate(sard)
```

### Remove overlaps

We'll look at a simple example to show how `linear` results from `auto_rate` may overlap.

```{r results='hide'}
urch_ar <- auto_rate(urchins.rd, plot = FALSE)
plot_ar(urch_ar)
```

```{r}
urch_ar_sub <- subset_rate(urch_ar,
                           method = "overlap",
                           n = 0.5,
                           plot = FALSE)
plot_ar(urch_ar_sub)
```

Let's look at a more complex example.

```{r results='hide'}
sard_ar <- auto_rate(sardine.rd, plot = FALSE)
plot_ar(sard_ar)
```


```{r}
sard_ar_sub <- subset_rate(sard_ar,
                           method = "overlap",
                           n = 0.5,
                           plot = FALSE)
plot_ar(sard_ar_sub)
```


### Summary of all - piping
