---
title: "respR - An R package for processing respirometry-related data"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{respR - An R package for processing respirometry-related data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = F}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>", fig.width=7, fig.height=7)
```

## Introduction
`respR` is an R package that provides a structural, reproducible workflow for the processing and analysis of respirometry-related data. While the focus of our package is on aquatic respirometry, it is highly likely that the 6 main functions in `respR` will work for any serial measurements of oxygen concentration (e.g. oxygen flux or photosynthesis data).

### Installation

The stable version of `respR` is available on GitHub and (soon) CRAN.

```{r, eval=F}
# CRAN
# install.packages("respR")  # preparing for submission, does not work
#
# GitHub
# install.packages("devtools")  # run if devtools is not installed
devtools::install_github("januarharianto/respR")
```


### Usage
When working with respirometry data, you will often need to:

1. Ensure that the data, or at least a subset of the data, is representative of the research question of interest.
2. Perform an initial analysis of the data to estimate the rate of change in oxygen concentration or amount.
3. Correct for background usage of oxygen by micro-organisms.
4. Scale the resulting usage rate to the volume (of the medium) and mass (of the animal), and convert to appropriate units.

The `respR` package contains several functions to make these actions quick and easy:

- It provides visual feedbacks and diagnostic plots to help you subset and analyse your data.
- It uses computational techniques such as rolling regressions and kernel density estimates to estimate ranked maximum, minimum or best fit sections of the data.
- By separating the workflow into a series of connected functions, you can "mix and match" functions to help you achieve your result.

### Functions

There are 6 main functions in `respR`:

1. `check.input()` checks for structural errors and select individual data from multi-column datasets.
2. `calc.bg.rate()` calculates background changes in oxygen concentration, e.g. from 'blank' experiments.
3. `calc.rate()` calculates the rate of change of oxygen concentration over time in a data frame, or its subset.
5. `auto.rate()` automatically determines maximum, minimum, or "best fit" rate of change of DO over time.
6. `calc.mo2()` converts a number, or an object of class `auto.rate` or `calc.rate`, to volume and/or weight-specific rates of change in oxygen concentration.

In addition, a few useful functions exist for specific data preparation and analysis scenarios:

7. `convert.do()` converts dissolved oxygen units (e.g. from % to mg/L).
8. `subsample.data()` thins a large dataset by sampling every *n* rows.
9. `pcrit()` calculates the breakpoint in metabolic rate, based on methods in Yeager and Ultsch (1989).

## A typical workflow

To explore `respR` and its main functions we load the first example data, `urchin2013`. The dataset contains measurements of oxygen consumption in 16 individual sea urchins (*Heliocidaris erythrogramma*) and 2 "blank" measurements of background respiration (Harianto, *unpublished*). Detailed information about the data, including its source and methods, can be obtained with the command `?urchin2013`.


```{r}
library(respR)
data(urchin2013)
urchin2013
```


### Use `check.input()` to check for common errors

We first use `check.input` to scan the dataset for missing data, non-numeric data and equal data lengths. Two checks intended only for time data are also performed: checks for duplicate and unevenly-spaced data. However, all checks are performed on all columns in the data, regardless of data type.

```{r, eval=FALSE}
check.input(urchin2013)
```

We can also subset a 2-column data frame from the dataset directly, by specifying the *x* and *y* arguments that correspond to columns in the data frame. The function will automatically consider the first column (x) as time data, and the second column (y) as oxygen concentration data. Error checks will therefore be specific to the data types, and error messages are more informative (e.g. duplicates in time data will be called out).

With two-column data, `check.input()` will automatically remove NA data and produce a new data frame that we can use for subsequent analyses. A scatterplot of the data is produced automatically for quick visual inspection.

```{r, fig.width=7, fig.height=7}
u2 <- check.input(urchin2013, x = 1, y = 15)
```

From the plot, we can see irregularities in these data near the end of the timeseries (in this case the sea urchin had interfered with the oxygen sensor). A linear regression of the entire data series would therefore give an erroneous calculation of the true rate. We have several options to manage irregular, or non-linear portions of the data. For now, the data frame is saved as an object for later analysis.

**It should be noted that invoking `check.input` is optional** - the main functions in our package will readily accept any data frame as long as data are all numeric and error-free. Running `check.input` is a qualitative step that simply flags potential issues about the data before it is analysed.


### Use `calc.bg.rate()` to process background rates for later use

The presence of microorganisms in the respirometry medium may be a potential source of significant experimental bias, and we may want to account for background rates during experiments. Since background rates typically account for a small percentage of experimental rates, these often-called “blank” experiments are routinely conducted alongside, or before and after main experiments, and the rates are averaged across several datasets to obtain a more accurate estimate of the correction.

The function `calc.bg.rate()` can be used to simultaneously process multiple background rate measurements as long as they share the time data. In `urchin2013`, background respiration was recorded and saved in columns 18 and 19. We analyse the data using `calc.bg.rate()` and save the output as an object.

```{r}
ubg <- calc.bg.rate(urchin2013, xcol = 1, ycol = c(18:19), plot = F) # use "plot = T"" to see the plots
ubg # print
```

### Use `calc.rate()` to perform the linear regression

Calling the function `calc.rate()` on a data frame, with no additional arguments, will prompt the function to perform a linear regression on the entire data frame. The function will automatically consider the first column as time data, and the second column as oxygen concentration data.

```{r}
calc.rate(u2)
```

In many cases, there is a need to truncate or subset the data before rate is determined. For example, we may want to determine rate over an exact period of time, or within a threshold of O~2~ concentrations. Equipment interference or other factors may also cause irregularities or “spikes” in the data. We can work around the error(s) and subset the regions that are not erroneous and still obtain valid results.

Based on the `from` and `to` arguments, a user may use `calc.rate` to truncate data in any of 4 ways:

1. **Time period** (`by = "time"`) - *"What is the average rate over a 25 minute period?"*
2. **Total oxygen consumed/produced** (`by = "o2"`) - *"At what rate is oxygen consumed between saturation points of 95% and 80%?"*
3. **Proportion based on total oxygen consumed** (`by = "proportion"`) - *"What is the rate from halfway down the data?"*
4. **Precise subsetting by row** (`by = "row"`). - *"I'd like to subset between rows 11 and 273."*

Note that for values of O~2~ and time that do not match any value in the data, the function will identify the closest matching time or O~2~ values to the inputs, rounded down, and uses these for subsequent calculations.

Here we subset the data by time, and include background respiration that had been saved by `calc.bg.rate()`. We may also enter background adjustments manually, as long as this rate has been determined using the same units e.g. `background = -0.001`. Care should be taken to ensure this value has the correct sign. For example, background respiration typically represents a rate of subtraction of O~2~ from the medium, and is therefore a negative value. Calling `summary()` shows a summary of data subset locations. 


```{r}
u.rate <- calc.rate(u2, from = 4, to = 29, by = "time", bg = ubg)
u.rate # print
summary(u.rate)
```

Plotting the output provides a series of diagnostic plots of the data subset that was analysed.
```{r}
plot(u.rate)
```

### Use `calc.mo2()` to scale to volume- and/or mass-specific rates

Once the rate of change of oxygen has been determined, we may either want to calculate:

1. Total change in O~2~ per unit time; or
2. Mass-specific rate of change in O~2~.

The function `calc.mo2()` can be used to scale rate values to volume and/or mass. 

For example, the user may convert the output of `calc.rate` to O~2~ consumed over an hour:

```{r}
calc.mo2(u.rate, o2.unit = "mg/L", time.unit = "sec", output.unit = "mg/s", 
  volume = 1.89)
```

Or, the user may convert a known rate to a volume-corrected, mass-specific rate:

```{r}
calc.mo2(u.rate, o2.unit = "mgl-1", time.unit = "s", output.unit = "mg/s/kg",
  volume = 1.89, mass = 0.13)
```

A string matching algorithm is used to automatically recognise variations in base units. For example, `"ml/s"`, `"mL/sec"`, `"milliliter/s"`, and `"millilitre/second"` are all equally identified as `mL/s`. Unit delimiters can be any combination of a space, dot (`.`), forward-slash (`/`), or the "per" unit (`-1`). Thus, `"ml/kg"`, `"mL / kg"`, `"mL /kilogram"`, `"ml kg-1"` or `"ml.kg-1"` are equally recognised as `mL/kg`.

Due to the "fuzzy" approach in the matching algorithm, writing unit strings for `calc.mo2()` should come naturally and intuitively for most people. As long as the units are recognised by the function, the conversion will take place. If we need a reminder on what units are available to use, we can call `unit.args()`:

```{r}
unit.args()
```


## Reproducibility

We have ensured that any computational analysis performed by `respR` can be reproduced by another user. The main functions all produce an output list object which contains all the data and variables needed to re-analyse the results, within R or in other software. Individual objects in the list can be extracted using `$` for verification or further data manipulation, which include the original and subset data frames.

```{r}
# grab subset locations that were used to subset the main data frame:
u.rate$results
```


## Further reading

This document introduces to you the basic methods of analysing respirometry data, but there are many other functions and user cases not explored. The following vignettes provide additional example workflows based on user needs, and may be useful to you:

1. [Measuring intermittent data](intermittent.html).
2. Maximum, minimum and interval analyses.
3. Pcrit setup and analyses


## Code

```{r, eval=F}
data(urchin2013)  # preload data
u2 <- check.input(df = urchin2013, x = 1, y = 15)  # subset the data and check its validity
ubg <- calc.bg.rate(urchin2013, timecol = 1, bgcol = c(18:19), plot = T) # calculate background rate
u.rate <- calc.rate(u2, from = 4, to = 29, by = "time", background = ubg)  # perform regression
plot(u.rate)  # view plot diagnostics of regression
# calculate mass-specific MO2, given known volume of container and mass of specimen:
calc.mo2(u.rate, o2.unit = "mgl-1", time.unit = "s", output.unit = "mg/s/kg", 
  volume = 1.89, mass = 0.13)

```
